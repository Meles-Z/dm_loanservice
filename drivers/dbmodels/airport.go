// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// Airport is an object representing the database table.
type Airport struct {
	ID               string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	Createdat        time.Time   `boil:"createdat" json:"createdat" toml:"createdat" yaml:"createdat"`
	Updatedat        time.Time   `boil:"updatedat" json:"updatedat" toml:"updatedat" yaml:"updatedat"`
	Iata             string      `boil:"iata" json:"iata" toml:"iata" yaml:"iata"`
	Icao             string      `boil:"icao" json:"icao" toml:"icao" yaml:"icao"`
	Name             string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	Latitude         null.String `boil:"latitude" json:"latitude,omitempty" toml:"latitude" yaml:"latitude,omitempty"`
	Longitude        null.String `boil:"longitude" json:"longitude,omitempty" toml:"longitude" yaml:"longitude,omitempty"`
	Altitudeinmetres null.Int64  `boil:"altitudeinmetres" json:"altitudeinmetres,omitempty" toml:"altitudeinmetres" yaml:"altitudeinmetres,omitempty"`
	Searchweighting  int64       `boil:"searchweighting" json:"searchweighting" toml:"searchweighting" yaml:"searchweighting"`
	Cityid           int64       `boil:"cityid" json:"cityid" toml:"cityid" yaml:"cityid"`

	R *airportR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L airportL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AirportColumns = struct {
	ID               string
	Createdat        string
	Updatedat        string
	Iata             string
	Icao             string
	Name             string
	Latitude         string
	Longitude        string
	Altitudeinmetres string
	Searchweighting  string
	Cityid           string
}{
	ID:               "id",
	Createdat:        "createdat",
	Updatedat:        "updatedat",
	Iata:             "iata",
	Icao:             "icao",
	Name:             "name",
	Latitude:         "latitude",
	Longitude:        "longitude",
	Altitudeinmetres: "altitudeinmetres",
	Searchweighting:  "searchweighting",
	Cityid:           "cityid",
}

var AirportTableColumns = struct {
	ID               string
	Createdat        string
	Updatedat        string
	Iata             string
	Icao             string
	Name             string
	Latitude         string
	Longitude        string
	Altitudeinmetres string
	Searchweighting  string
	Cityid           string
}{
	ID:               "airport.id",
	Createdat:        "airport.createdat",
	Updatedat:        "airport.updatedat",
	Iata:             "airport.iata",
	Icao:             "airport.icao",
	Name:             "airport.name",
	Latitude:         "airport.latitude",
	Longitude:        "airport.longitude",
	Altitudeinmetres: "airport.altitudeinmetres",
	Searchweighting:  "airport.searchweighting",
	Cityid:           "airport.cityid",
}

// Generated where

var AirportWhere = struct {
	ID               whereHelperstring
	Createdat        whereHelpertime_Time
	Updatedat        whereHelpertime_Time
	Iata             whereHelperstring
	Icao             whereHelperstring
	Name             whereHelperstring
	Latitude         whereHelpernull_String
	Longitude        whereHelpernull_String
	Altitudeinmetres whereHelpernull_Int64
	Searchweighting  whereHelperint64
	Cityid           whereHelperint64
}{
	ID:               whereHelperstring{field: "\"airport\".\"id\""},
	Createdat:        whereHelpertime_Time{field: "\"airport\".\"createdat\""},
	Updatedat:        whereHelpertime_Time{field: "\"airport\".\"updatedat\""},
	Iata:             whereHelperstring{field: "\"airport\".\"iata\""},
	Icao:             whereHelperstring{field: "\"airport\".\"icao\""},
	Name:             whereHelperstring{field: "\"airport\".\"name\""},
	Latitude:         whereHelpernull_String{field: "\"airport\".\"latitude\""},
	Longitude:        whereHelpernull_String{field: "\"airport\".\"longitude\""},
	Altitudeinmetres: whereHelpernull_Int64{field: "\"airport\".\"altitudeinmetres\""},
	Searchweighting:  whereHelperint64{field: "\"airport\".\"searchweighting\""},
	Cityid:           whereHelperint64{field: "\"airport\".\"cityid\""},
}

// AirportRels is where relationship names are stored.
var AirportRels = struct {
	CityidCity                 string
	FromAirportEmptyLegs       string
	ToAirportEmptyLegs         string
	FromAirportFlightRequests  string
	ToAirportFlightRequests    string
	FromAirportFlightsGroups   string
	ToAirportFlightsGroups     string
	FromAirportQuotes          string
	ToAirportQuotes            string
	FromAirportQuoteHeaders    string
	ToAirportQuoteHeaders      string
	FromAirportQuoteOperations string
	ToAirportQuoteOperations   string
}{
	CityidCity:                 "CityidCity",
	FromAirportEmptyLegs:       "FromAirportEmptyLegs",
	ToAirportEmptyLegs:         "ToAirportEmptyLegs",
	FromAirportFlightRequests:  "FromAirportFlightRequests",
	ToAirportFlightRequests:    "ToAirportFlightRequests",
	FromAirportFlightsGroups:   "FromAirportFlightsGroups",
	ToAirportFlightsGroups:     "ToAirportFlightsGroups",
	FromAirportQuotes:          "FromAirportQuotes",
	ToAirportQuotes:            "ToAirportQuotes",
	FromAirportQuoteHeaders:    "FromAirportQuoteHeaders",
	ToAirportQuoteHeaders:      "ToAirportQuoteHeaders",
	FromAirportQuoteOperations: "FromAirportQuoteOperations",
	ToAirportQuoteOperations:   "ToAirportQuoteOperations",
}

// airportR is where relationships are stored.
type airportR struct {
	CityidCity                 *City               `boil:"CityidCity" json:"CityidCity" toml:"CityidCity" yaml:"CityidCity"`
	FromAirportEmptyLegs       EmptyLegSlice       `boil:"FromAirportEmptyLegs" json:"FromAirportEmptyLegs" toml:"FromAirportEmptyLegs" yaml:"FromAirportEmptyLegs"`
	ToAirportEmptyLegs         EmptyLegSlice       `boil:"ToAirportEmptyLegs" json:"ToAirportEmptyLegs" toml:"ToAirportEmptyLegs" yaml:"ToAirportEmptyLegs"`
	FromAirportFlightRequests  FlightRequestSlice  `boil:"FromAirportFlightRequests" json:"FromAirportFlightRequests" toml:"FromAirportFlightRequests" yaml:"FromAirportFlightRequests"`
	ToAirportFlightRequests    FlightRequestSlice  `boil:"ToAirportFlightRequests" json:"ToAirportFlightRequests" toml:"ToAirportFlightRequests" yaml:"ToAirportFlightRequests"`
	FromAirportFlightsGroups   FlightsGroupSlice   `boil:"FromAirportFlightsGroups" json:"FromAirportFlightsGroups" toml:"FromAirportFlightsGroups" yaml:"FromAirportFlightsGroups"`
	ToAirportFlightsGroups     FlightsGroupSlice   `boil:"ToAirportFlightsGroups" json:"ToAirportFlightsGroups" toml:"ToAirportFlightsGroups" yaml:"ToAirportFlightsGroups"`
	FromAirportQuotes          QuoteSlice          `boil:"FromAirportQuotes" json:"FromAirportQuotes" toml:"FromAirportQuotes" yaml:"FromAirportQuotes"`
	ToAirportQuotes            QuoteSlice          `boil:"ToAirportQuotes" json:"ToAirportQuotes" toml:"ToAirportQuotes" yaml:"ToAirportQuotes"`
	FromAirportQuoteHeaders    QuoteHeaderSlice    `boil:"FromAirportQuoteHeaders" json:"FromAirportQuoteHeaders" toml:"FromAirportQuoteHeaders" yaml:"FromAirportQuoteHeaders"`
	ToAirportQuoteHeaders      QuoteHeaderSlice    `boil:"ToAirportQuoteHeaders" json:"ToAirportQuoteHeaders" toml:"ToAirportQuoteHeaders" yaml:"ToAirportQuoteHeaders"`
	FromAirportQuoteOperations QuoteOperationSlice `boil:"FromAirportQuoteOperations" json:"FromAirportQuoteOperations" toml:"FromAirportQuoteOperations" yaml:"FromAirportQuoteOperations"`
	ToAirportQuoteOperations   QuoteOperationSlice `boil:"ToAirportQuoteOperations" json:"ToAirportQuoteOperations" toml:"ToAirportQuoteOperations" yaml:"ToAirportQuoteOperations"`
}

// NewStruct creates a new relationship struct
func (*airportR) NewStruct() *airportR {
	return &airportR{}
}

func (o *Airport) GetCityidCity() *City {
	if o == nil {
		return nil
	}

	return o.R.GetCityidCity()
}

func (r *airportR) GetCityidCity() *City {
	if r == nil {
		return nil
	}

	return r.CityidCity
}

func (o *Airport) GetFromAirportEmptyLegs() EmptyLegSlice {
	if o == nil {
		return nil
	}

	return o.R.GetFromAirportEmptyLegs()
}

func (r *airportR) GetFromAirportEmptyLegs() EmptyLegSlice {
	if r == nil {
		return nil
	}

	return r.FromAirportEmptyLegs
}

func (o *Airport) GetToAirportEmptyLegs() EmptyLegSlice {
	if o == nil {
		return nil
	}

	return o.R.GetToAirportEmptyLegs()
}

func (r *airportR) GetToAirportEmptyLegs() EmptyLegSlice {
	if r == nil {
		return nil
	}

	return r.ToAirportEmptyLegs
}

func (o *Airport) GetFromAirportFlightRequests() FlightRequestSlice {
	if o == nil {
		return nil
	}

	return o.R.GetFromAirportFlightRequests()
}

func (r *airportR) GetFromAirportFlightRequests() FlightRequestSlice {
	if r == nil {
		return nil
	}

	return r.FromAirportFlightRequests
}

func (o *Airport) GetToAirportFlightRequests() FlightRequestSlice {
	if o == nil {
		return nil
	}

	return o.R.GetToAirportFlightRequests()
}

func (r *airportR) GetToAirportFlightRequests() FlightRequestSlice {
	if r == nil {
		return nil
	}

	return r.ToAirportFlightRequests
}

func (o *Airport) GetFromAirportFlightsGroups() FlightsGroupSlice {
	if o == nil {
		return nil
	}

	return o.R.GetFromAirportFlightsGroups()
}

func (r *airportR) GetFromAirportFlightsGroups() FlightsGroupSlice {
	if r == nil {
		return nil
	}

	return r.FromAirportFlightsGroups
}

func (o *Airport) GetToAirportFlightsGroups() FlightsGroupSlice {
	if o == nil {
		return nil
	}

	return o.R.GetToAirportFlightsGroups()
}

func (r *airportR) GetToAirportFlightsGroups() FlightsGroupSlice {
	if r == nil {
		return nil
	}

	return r.ToAirportFlightsGroups
}

func (o *Airport) GetFromAirportQuotes() QuoteSlice {
	if o == nil {
		return nil
	}

	return o.R.GetFromAirportQuotes()
}

func (r *airportR) GetFromAirportQuotes() QuoteSlice {
	if r == nil {
		return nil
	}

	return r.FromAirportQuotes
}

func (o *Airport) GetToAirportQuotes() QuoteSlice {
	if o == nil {
		return nil
	}

	return o.R.GetToAirportQuotes()
}

func (r *airportR) GetToAirportQuotes() QuoteSlice {
	if r == nil {
		return nil
	}

	return r.ToAirportQuotes
}

func (o *Airport) GetFromAirportQuoteHeaders() QuoteHeaderSlice {
	if o == nil {
		return nil
	}

	return o.R.GetFromAirportQuoteHeaders()
}

func (r *airportR) GetFromAirportQuoteHeaders() QuoteHeaderSlice {
	if r == nil {
		return nil
	}

	return r.FromAirportQuoteHeaders
}

func (o *Airport) GetToAirportQuoteHeaders() QuoteHeaderSlice {
	if o == nil {
		return nil
	}

	return o.R.GetToAirportQuoteHeaders()
}

func (r *airportR) GetToAirportQuoteHeaders() QuoteHeaderSlice {
	if r == nil {
		return nil
	}

	return r.ToAirportQuoteHeaders
}

func (o *Airport) GetFromAirportQuoteOperations() QuoteOperationSlice {
	if o == nil {
		return nil
	}

	return o.R.GetFromAirportQuoteOperations()
}

func (r *airportR) GetFromAirportQuoteOperations() QuoteOperationSlice {
	if r == nil {
		return nil
	}

	return r.FromAirportQuoteOperations
}

func (o *Airport) GetToAirportQuoteOperations() QuoteOperationSlice {
	if o == nil {
		return nil
	}

	return o.R.GetToAirportQuoteOperations()
}

func (r *airportR) GetToAirportQuoteOperations() QuoteOperationSlice {
	if r == nil {
		return nil
	}

	return r.ToAirportQuoteOperations
}

// airportL is where Load methods for each relationship are stored.
type airportL struct{}

var (
	airportAllColumns            = []string{"id", "createdat", "updatedat", "iata", "icao", "name", "latitude", "longitude", "altitudeinmetres", "searchweighting", "cityid"}
	airportColumnsWithoutDefault = []string{"id", "updatedat", "iata", "icao", "name", "cityid"}
	airportColumnsWithDefault    = []string{"createdat", "latitude", "longitude", "altitudeinmetres", "searchweighting"}
	airportPrimaryKeyColumns     = []string{"id"}
	airportGeneratedColumns      = []string{}
)

type (
	// AirportSlice is an alias for a slice of pointers to Airport.
	// This should almost always be used instead of []Airport.
	AirportSlice []*Airport
	// AirportHook is the signature for custom Airport hook methods
	AirportHook func(context.Context, boil.ContextExecutor, *Airport) error

	airportQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	airportType                 = reflect.TypeOf(&Airport{})
	airportMapping              = queries.MakeStructMapping(airportType)
	airportPrimaryKeyMapping, _ = queries.BindMapping(airportType, airportMapping, airportPrimaryKeyColumns)
	airportInsertCacheMut       sync.RWMutex
	airportInsertCache          = make(map[string]insertCache)
	airportUpdateCacheMut       sync.RWMutex
	airportUpdateCache          = make(map[string]updateCache)
	airportUpsertCacheMut       sync.RWMutex
	airportUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var airportAfterSelectMu sync.Mutex
var airportAfterSelectHooks []AirportHook

var airportBeforeInsertMu sync.Mutex
var airportBeforeInsertHooks []AirportHook
var airportAfterInsertMu sync.Mutex
var airportAfterInsertHooks []AirportHook

var airportBeforeUpdateMu sync.Mutex
var airportBeforeUpdateHooks []AirportHook
var airportAfterUpdateMu sync.Mutex
var airportAfterUpdateHooks []AirportHook

var airportBeforeDeleteMu sync.Mutex
var airportBeforeDeleteHooks []AirportHook
var airportAfterDeleteMu sync.Mutex
var airportAfterDeleteHooks []AirportHook

var airportBeforeUpsertMu sync.Mutex
var airportBeforeUpsertHooks []AirportHook
var airportAfterUpsertMu sync.Mutex
var airportAfterUpsertHooks []AirportHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Airport) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range airportAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Airport) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range airportBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Airport) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range airportAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Airport) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range airportBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Airport) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range airportAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Airport) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range airportBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Airport) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range airportAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Airport) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range airportBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Airport) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range airportAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddAirportHook registers your hook function for all future operations.
func AddAirportHook(hookPoint boil.HookPoint, airportHook AirportHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		airportAfterSelectMu.Lock()
		airportAfterSelectHooks = append(airportAfterSelectHooks, airportHook)
		airportAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		airportBeforeInsertMu.Lock()
		airportBeforeInsertHooks = append(airportBeforeInsertHooks, airportHook)
		airportBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		airportAfterInsertMu.Lock()
		airportAfterInsertHooks = append(airportAfterInsertHooks, airportHook)
		airportAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		airportBeforeUpdateMu.Lock()
		airportBeforeUpdateHooks = append(airportBeforeUpdateHooks, airportHook)
		airportBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		airportAfterUpdateMu.Lock()
		airportAfterUpdateHooks = append(airportAfterUpdateHooks, airportHook)
		airportAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		airportBeforeDeleteMu.Lock()
		airportBeforeDeleteHooks = append(airportBeforeDeleteHooks, airportHook)
		airportBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		airportAfterDeleteMu.Lock()
		airportAfterDeleteHooks = append(airportAfterDeleteHooks, airportHook)
		airportAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		airportBeforeUpsertMu.Lock()
		airportBeforeUpsertHooks = append(airportBeforeUpsertHooks, airportHook)
		airportBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		airportAfterUpsertMu.Lock()
		airportAfterUpsertHooks = append(airportAfterUpsertHooks, airportHook)
		airportAfterUpsertMu.Unlock()
	}
}

// One returns a single airport record from the query.
func (q airportQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Airport, error) {
	o := &Airport{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for airport")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Airport records from the query.
func (q airportQuery) All(ctx context.Context, exec boil.ContextExecutor) (AirportSlice, error) {
	var o []*Airport

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to Airport slice")
	}

	if len(airportAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Airport records in the query.
func (q airportQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count airport rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q airportQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if airport exists")
	}

	return count > 0, nil
}

// CityidCity pointed to by the foreign key.
func (o *Airport) CityidCity(mods ...qm.QueryMod) cityQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.Cityid),
	}

	queryMods = append(queryMods, mods...)

	return Cities(queryMods...)
}

// FromAirportEmptyLegs retrieves all the empty_leg's EmptyLegs with an executor via from_airport_id column.
func (o *Airport) FromAirportEmptyLegs(mods ...qm.QueryMod) emptyLegQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"empty_leg\".\"from_airport_id\"=?", o.ID),
	)

	return EmptyLegs(queryMods...)
}

// ToAirportEmptyLegs retrieves all the empty_leg's EmptyLegs with an executor via to_airport_id column.
func (o *Airport) ToAirportEmptyLegs(mods ...qm.QueryMod) emptyLegQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"empty_leg\".\"to_airport_id\"=?", o.ID),
	)

	return EmptyLegs(queryMods...)
}

// FromAirportFlightRequests retrieves all the flight_request's FlightRequests with an executor via from_airport_id column.
func (o *Airport) FromAirportFlightRequests(mods ...qm.QueryMod) flightRequestQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"flight_request\".\"from_airport_id\"=?", o.ID),
	)

	return FlightRequests(queryMods...)
}

// ToAirportFlightRequests retrieves all the flight_request's FlightRequests with an executor via to_airport_id column.
func (o *Airport) ToAirportFlightRequests(mods ...qm.QueryMod) flightRequestQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"flight_request\".\"to_airport_id\"=?", o.ID),
	)

	return FlightRequests(queryMods...)
}

// FromAirportFlightsGroups retrieves all the flights_group's FlightsGroups with an executor via from_airport_id column.
func (o *Airport) FromAirportFlightsGroups(mods ...qm.QueryMod) flightsGroupQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"flights_group\".\"from_airport_id\"=?", o.ID),
	)

	return FlightsGroups(queryMods...)
}

// ToAirportFlightsGroups retrieves all the flights_group's FlightsGroups with an executor via to_airport_id column.
func (o *Airport) ToAirportFlightsGroups(mods ...qm.QueryMod) flightsGroupQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"flights_group\".\"to_airport_id\"=?", o.ID),
	)

	return FlightsGroups(queryMods...)
}

// FromAirportQuotes retrieves all the quote's Quotes with an executor via from_airport_id column.
func (o *Airport) FromAirportQuotes(mods ...qm.QueryMod) quoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"quote\".\"from_airport_id\"=?", o.ID),
	)

	return Quotes(queryMods...)
}

// ToAirportQuotes retrieves all the quote's Quotes with an executor via to_airport_id column.
func (o *Airport) ToAirportQuotes(mods ...qm.QueryMod) quoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"quote\".\"to_airport_id\"=?", o.ID),
	)

	return Quotes(queryMods...)
}

// FromAirportQuoteHeaders retrieves all the quote_header's QuoteHeaders with an executor via from_airport_id column.
func (o *Airport) FromAirportQuoteHeaders(mods ...qm.QueryMod) quoteHeaderQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"quote_header\".\"from_airport_id\"=?", o.ID),
	)

	return QuoteHeaders(queryMods...)
}

// ToAirportQuoteHeaders retrieves all the quote_header's QuoteHeaders with an executor via to_airport_id column.
func (o *Airport) ToAirportQuoteHeaders(mods ...qm.QueryMod) quoteHeaderQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"quote_header\".\"to_airport_id\"=?", o.ID),
	)

	return QuoteHeaders(queryMods...)
}

// FromAirportQuoteOperations retrieves all the quote_operation's QuoteOperations with an executor via from_airport_id column.
func (o *Airport) FromAirportQuoteOperations(mods ...qm.QueryMod) quoteOperationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"quote_operation\".\"from_airport_id\"=?", o.ID),
	)

	return QuoteOperations(queryMods...)
}

// ToAirportQuoteOperations retrieves all the quote_operation's QuoteOperations with an executor via to_airport_id column.
func (o *Airport) ToAirportQuoteOperations(mods ...qm.QueryMod) quoteOperationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"quote_operation\".\"to_airport_id\"=?", o.ID),
	)

	return QuoteOperations(queryMods...)
}

// LoadCityidCity allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (airportL) LoadCityidCity(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.Cityid] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}

			args[obj.Cityid] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`city`),
		qm.WhereIn(`city.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load City")
	}

	var resultSlice []*City
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice City")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for city")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for city")
	}

	if len(cityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CityidCity = foreign
		if foreign.R == nil {
			foreign.R = &cityR{}
		}
		foreign.R.CityidAirports = append(foreign.R.CityidAirports, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Cityid == foreign.ID {
				local.R.CityidCity = foreign
				if foreign.R == nil {
					foreign.R = &cityR{}
				}
				foreign.R.CityidAirports = append(foreign.R.CityidAirports, local)
				break
			}
		}
	}

	return nil
}

// LoadFromAirportEmptyLegs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (airportL) LoadFromAirportEmptyLegs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`empty_leg`),
		qm.WhereIn(`empty_leg.from_airport_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load empty_leg")
	}

	var resultSlice []*EmptyLeg
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice empty_leg")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on empty_leg")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for empty_leg")
	}

	if len(emptyLegAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromAirportEmptyLegs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &emptyLegR{}
			}
			foreign.R.FromAirport = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FromAirportID {
				local.R.FromAirportEmptyLegs = append(local.R.FromAirportEmptyLegs, foreign)
				if foreign.R == nil {
					foreign.R = &emptyLegR{}
				}
				foreign.R.FromAirport = local
				break
			}
		}
	}

	return nil
}

// LoadToAirportEmptyLegs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (airportL) LoadToAirportEmptyLegs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`empty_leg`),
		qm.WhereIn(`empty_leg.to_airport_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load empty_leg")
	}

	var resultSlice []*EmptyLeg
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice empty_leg")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on empty_leg")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for empty_leg")
	}

	if len(emptyLegAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToAirportEmptyLegs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &emptyLegR{}
			}
			foreign.R.ToAirport = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ToAirportID {
				local.R.ToAirportEmptyLegs = append(local.R.ToAirportEmptyLegs, foreign)
				if foreign.R == nil {
					foreign.R = &emptyLegR{}
				}
				foreign.R.ToAirport = local
				break
			}
		}
	}

	return nil
}

// LoadFromAirportFlightRequests allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (airportL) LoadFromAirportFlightRequests(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`flight_request`),
		qm.WhereIn(`flight_request.from_airport_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load flight_request")
	}

	var resultSlice []*FlightRequest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice flight_request")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on flight_request")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for flight_request")
	}

	if len(flightRequestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromAirportFlightRequests = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &flightRequestR{}
			}
			foreign.R.FromAirport = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FromAirportID {
				local.R.FromAirportFlightRequests = append(local.R.FromAirportFlightRequests, foreign)
				if foreign.R == nil {
					foreign.R = &flightRequestR{}
				}
				foreign.R.FromAirport = local
				break
			}
		}
	}

	return nil
}

// LoadToAirportFlightRequests allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (airportL) LoadToAirportFlightRequests(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`flight_request`),
		qm.WhereIn(`flight_request.to_airport_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load flight_request")
	}

	var resultSlice []*FlightRequest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice flight_request")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on flight_request")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for flight_request")
	}

	if len(flightRequestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToAirportFlightRequests = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &flightRequestR{}
			}
			foreign.R.ToAirport = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ToAirportID {
				local.R.ToAirportFlightRequests = append(local.R.ToAirportFlightRequests, foreign)
				if foreign.R == nil {
					foreign.R = &flightRequestR{}
				}
				foreign.R.ToAirport = local
				break
			}
		}
	}

	return nil
}

// LoadFromAirportFlightsGroups allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (airportL) LoadFromAirportFlightsGroups(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`flights_group`),
		qm.WhereIn(`flights_group.from_airport_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load flights_group")
	}

	var resultSlice []*FlightsGroup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice flights_group")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on flights_group")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for flights_group")
	}

	if len(flightsGroupAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromAirportFlightsGroups = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &flightsGroupR{}
			}
			foreign.R.FromAirport = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FromAirportID {
				local.R.FromAirportFlightsGroups = append(local.R.FromAirportFlightsGroups, foreign)
				if foreign.R == nil {
					foreign.R = &flightsGroupR{}
				}
				foreign.R.FromAirport = local
				break
			}
		}
	}

	return nil
}

// LoadToAirportFlightsGroups allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (airportL) LoadToAirportFlightsGroups(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`flights_group`),
		qm.WhereIn(`flights_group.to_airport_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load flights_group")
	}

	var resultSlice []*FlightsGroup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice flights_group")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on flights_group")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for flights_group")
	}

	if len(flightsGroupAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToAirportFlightsGroups = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &flightsGroupR{}
			}
			foreign.R.ToAirport = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ToAirportID {
				local.R.ToAirportFlightsGroups = append(local.R.ToAirportFlightsGroups, foreign)
				if foreign.R == nil {
					foreign.R = &flightsGroupR{}
				}
				foreign.R.ToAirport = local
				break
			}
		}
	}

	return nil
}

// LoadFromAirportQuotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (airportL) LoadFromAirportQuotes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`quote`),
		qm.WhereIn(`quote.from_airport_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load quote")
	}

	var resultSlice []*Quote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice quote")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on quote")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quote")
	}

	if len(quoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromAirportQuotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &quoteR{}
			}
			foreign.R.FromAirport = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FromAirportID {
				local.R.FromAirportQuotes = append(local.R.FromAirportQuotes, foreign)
				if foreign.R == nil {
					foreign.R = &quoteR{}
				}
				foreign.R.FromAirport = local
				break
			}
		}
	}

	return nil
}

// LoadToAirportQuotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (airportL) LoadToAirportQuotes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`quote`),
		qm.WhereIn(`quote.to_airport_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load quote")
	}

	var resultSlice []*Quote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice quote")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on quote")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quote")
	}

	if len(quoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToAirportQuotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &quoteR{}
			}
			foreign.R.ToAirport = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ToAirportID {
				local.R.ToAirportQuotes = append(local.R.ToAirportQuotes, foreign)
				if foreign.R == nil {
					foreign.R = &quoteR{}
				}
				foreign.R.ToAirport = local
				break
			}
		}
	}

	return nil
}

// LoadFromAirportQuoteHeaders allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (airportL) LoadFromAirportQuoteHeaders(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`quote_header`),
		qm.WhereIn(`quote_header.from_airport_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load quote_header")
	}

	var resultSlice []*QuoteHeader
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice quote_header")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on quote_header")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quote_header")
	}

	if len(quoteHeaderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromAirportQuoteHeaders = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &quoteHeaderR{}
			}
			foreign.R.FromAirport = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FromAirportID {
				local.R.FromAirportQuoteHeaders = append(local.R.FromAirportQuoteHeaders, foreign)
				if foreign.R == nil {
					foreign.R = &quoteHeaderR{}
				}
				foreign.R.FromAirport = local
				break
			}
		}
	}

	return nil
}

// LoadToAirportQuoteHeaders allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (airportL) LoadToAirportQuoteHeaders(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`quote_header`),
		qm.WhereIn(`quote_header.to_airport_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load quote_header")
	}

	var resultSlice []*QuoteHeader
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice quote_header")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on quote_header")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quote_header")
	}

	if len(quoteHeaderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToAirportQuoteHeaders = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &quoteHeaderR{}
			}
			foreign.R.ToAirport = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ToAirportID {
				local.R.ToAirportQuoteHeaders = append(local.R.ToAirportQuoteHeaders, foreign)
				if foreign.R == nil {
					foreign.R = &quoteHeaderR{}
				}
				foreign.R.ToAirport = local
				break
			}
		}
	}

	return nil
}

// LoadFromAirportQuoteOperations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (airportL) LoadFromAirportQuoteOperations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`quote_operation`),
		qm.WhereIn(`quote_operation.from_airport_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load quote_operation")
	}

	var resultSlice []*QuoteOperation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice quote_operation")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on quote_operation")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quote_operation")
	}

	if len(quoteOperationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromAirportQuoteOperations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &quoteOperationR{}
			}
			foreign.R.FromAirport = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FromAirportID {
				local.R.FromAirportQuoteOperations = append(local.R.FromAirportQuoteOperations, foreign)
				if foreign.R == nil {
					foreign.R = &quoteOperationR{}
				}
				foreign.R.FromAirport = local
				break
			}
		}
	}

	return nil
}

// LoadToAirportQuoteOperations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (airportL) LoadToAirportQuoteOperations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAirport interface{}, mods queries.Applicator) error {
	var slice []*Airport
	var object *Airport

	if singular {
		var ok bool
		object, ok = maybeAirport.(*Airport)
		if !ok {
			object = new(Airport)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAirport))
			}
		}
	} else {
		s, ok := maybeAirport.(*[]*Airport)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAirport)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAirport))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &airportR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &airportR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`quote_operation`),
		qm.WhereIn(`quote_operation.to_airport_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load quote_operation")
	}

	var resultSlice []*QuoteOperation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice quote_operation")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on quote_operation")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quote_operation")
	}

	if len(quoteOperationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToAirportQuoteOperations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &quoteOperationR{}
			}
			foreign.R.ToAirport = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ToAirportID {
				local.R.ToAirportQuoteOperations = append(local.R.ToAirportQuoteOperations, foreign)
				if foreign.R == nil {
					foreign.R = &quoteOperationR{}
				}
				foreign.R.ToAirport = local
				break
			}
		}
	}

	return nil
}

// SetCityidCity of the airport to the related item.
// Sets o.R.CityidCity to related.
// Adds o to related.R.CityidAirports.
func (o *Airport) SetCityidCity(ctx context.Context, exec boil.ContextExecutor, insert bool, related *City) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"airport\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"cityid"}),
		strmangle.WhereClause("\"", "\"", 2, airportPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Cityid = related.ID
	if o.R == nil {
		o.R = &airportR{
			CityidCity: related,
		}
	} else {
		o.R.CityidCity = related
	}

	if related.R == nil {
		related.R = &cityR{
			CityidAirports: AirportSlice{o},
		}
	} else {
		related.R.CityidAirports = append(related.R.CityidAirports, o)
	}

	return nil
}

// AddFromAirportEmptyLegs adds the given related objects to the existing relationships
// of the airport, optionally inserting them as new records.
// Appends related to o.R.FromAirportEmptyLegs.
// Sets related.R.FromAirport appropriately.
func (o *Airport) AddFromAirportEmptyLegs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*EmptyLeg) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAirportID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"empty_leg\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"from_airport_id"}),
				strmangle.WhereClause("\"", "\"", 2, emptyLegPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAirportID = o.ID
		}
	}

	if o.R == nil {
		o.R = &airportR{
			FromAirportEmptyLegs: related,
		}
	} else {
		o.R.FromAirportEmptyLegs = append(o.R.FromAirportEmptyLegs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &emptyLegR{
				FromAirport: o,
			}
		} else {
			rel.R.FromAirport = o
		}
	}
	return nil
}

// AddToAirportEmptyLegs adds the given related objects to the existing relationships
// of the airport, optionally inserting them as new records.
// Appends related to o.R.ToAirportEmptyLegs.
// Sets related.R.ToAirport appropriately.
func (o *Airport) AddToAirportEmptyLegs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*EmptyLeg) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToAirportID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"empty_leg\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"to_airport_id"}),
				strmangle.WhereClause("\"", "\"", 2, emptyLegPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToAirportID = o.ID
		}
	}

	if o.R == nil {
		o.R = &airportR{
			ToAirportEmptyLegs: related,
		}
	} else {
		o.R.ToAirportEmptyLegs = append(o.R.ToAirportEmptyLegs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &emptyLegR{
				ToAirport: o,
			}
		} else {
			rel.R.ToAirport = o
		}
	}
	return nil
}

// AddFromAirportFlightRequests adds the given related objects to the existing relationships
// of the airport, optionally inserting them as new records.
// Appends related to o.R.FromAirportFlightRequests.
// Sets related.R.FromAirport appropriately.
func (o *Airport) AddFromAirportFlightRequests(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FlightRequest) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAirportID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"flight_request\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"from_airport_id"}),
				strmangle.WhereClause("\"", "\"", 2, flightRequestPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAirportID = o.ID
		}
	}

	if o.R == nil {
		o.R = &airportR{
			FromAirportFlightRequests: related,
		}
	} else {
		o.R.FromAirportFlightRequests = append(o.R.FromAirportFlightRequests, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &flightRequestR{
				FromAirport: o,
			}
		} else {
			rel.R.FromAirport = o
		}
	}
	return nil
}

// AddToAirportFlightRequests adds the given related objects to the existing relationships
// of the airport, optionally inserting them as new records.
// Appends related to o.R.ToAirportFlightRequests.
// Sets related.R.ToAirport appropriately.
func (o *Airport) AddToAirportFlightRequests(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FlightRequest) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToAirportID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"flight_request\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"to_airport_id"}),
				strmangle.WhereClause("\"", "\"", 2, flightRequestPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToAirportID = o.ID
		}
	}

	if o.R == nil {
		o.R = &airportR{
			ToAirportFlightRequests: related,
		}
	} else {
		o.R.ToAirportFlightRequests = append(o.R.ToAirportFlightRequests, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &flightRequestR{
				ToAirport: o,
			}
		} else {
			rel.R.ToAirport = o
		}
	}
	return nil
}

// AddFromAirportFlightsGroups adds the given related objects to the existing relationships
// of the airport, optionally inserting them as new records.
// Appends related to o.R.FromAirportFlightsGroups.
// Sets related.R.FromAirport appropriately.
func (o *Airport) AddFromAirportFlightsGroups(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FlightsGroup) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAirportID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"flights_group\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"from_airport_id"}),
				strmangle.WhereClause("\"", "\"", 2, flightsGroupPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAirportID = o.ID
		}
	}

	if o.R == nil {
		o.R = &airportR{
			FromAirportFlightsGroups: related,
		}
	} else {
		o.R.FromAirportFlightsGroups = append(o.R.FromAirportFlightsGroups, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &flightsGroupR{
				FromAirport: o,
			}
		} else {
			rel.R.FromAirport = o
		}
	}
	return nil
}

// AddToAirportFlightsGroups adds the given related objects to the existing relationships
// of the airport, optionally inserting them as new records.
// Appends related to o.R.ToAirportFlightsGroups.
// Sets related.R.ToAirport appropriately.
func (o *Airport) AddToAirportFlightsGroups(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FlightsGroup) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToAirportID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"flights_group\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"to_airport_id"}),
				strmangle.WhereClause("\"", "\"", 2, flightsGroupPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToAirportID = o.ID
		}
	}

	if o.R == nil {
		o.R = &airportR{
			ToAirportFlightsGroups: related,
		}
	} else {
		o.R.ToAirportFlightsGroups = append(o.R.ToAirportFlightsGroups, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &flightsGroupR{
				ToAirport: o,
			}
		} else {
			rel.R.ToAirport = o
		}
	}
	return nil
}

// AddFromAirportQuotes adds the given related objects to the existing relationships
// of the airport, optionally inserting them as new records.
// Appends related to o.R.FromAirportQuotes.
// Sets related.R.FromAirport appropriately.
func (o *Airport) AddFromAirportQuotes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Quote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAirportID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"quote\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"from_airport_id"}),
				strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAirportID = o.ID
		}
	}

	if o.R == nil {
		o.R = &airportR{
			FromAirportQuotes: related,
		}
	} else {
		o.R.FromAirportQuotes = append(o.R.FromAirportQuotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &quoteR{
				FromAirport: o,
			}
		} else {
			rel.R.FromAirport = o
		}
	}
	return nil
}

// AddToAirportQuotes adds the given related objects to the existing relationships
// of the airport, optionally inserting them as new records.
// Appends related to o.R.ToAirportQuotes.
// Sets related.R.ToAirport appropriately.
func (o *Airport) AddToAirportQuotes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Quote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToAirportID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"quote\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"to_airport_id"}),
				strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToAirportID = o.ID
		}
	}

	if o.R == nil {
		o.R = &airportR{
			ToAirportQuotes: related,
		}
	} else {
		o.R.ToAirportQuotes = append(o.R.ToAirportQuotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &quoteR{
				ToAirport: o,
			}
		} else {
			rel.R.ToAirport = o
		}
	}
	return nil
}

// AddFromAirportQuoteHeaders adds the given related objects to the existing relationships
// of the airport, optionally inserting them as new records.
// Appends related to o.R.FromAirportQuoteHeaders.
// Sets related.R.FromAirport appropriately.
func (o *Airport) AddFromAirportQuoteHeaders(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*QuoteHeader) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAirportID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"quote_header\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"from_airport_id"}),
				strmangle.WhereClause("\"", "\"", 2, quoteHeaderPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAirportID = o.ID
		}
	}

	if o.R == nil {
		o.R = &airportR{
			FromAirportQuoteHeaders: related,
		}
	} else {
		o.R.FromAirportQuoteHeaders = append(o.R.FromAirportQuoteHeaders, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &quoteHeaderR{
				FromAirport: o,
			}
		} else {
			rel.R.FromAirport = o
		}
	}
	return nil
}

// AddToAirportQuoteHeaders adds the given related objects to the existing relationships
// of the airport, optionally inserting them as new records.
// Appends related to o.R.ToAirportQuoteHeaders.
// Sets related.R.ToAirport appropriately.
func (o *Airport) AddToAirportQuoteHeaders(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*QuoteHeader) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToAirportID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"quote_header\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"to_airport_id"}),
				strmangle.WhereClause("\"", "\"", 2, quoteHeaderPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToAirportID = o.ID
		}
	}

	if o.R == nil {
		o.R = &airportR{
			ToAirportQuoteHeaders: related,
		}
	} else {
		o.R.ToAirportQuoteHeaders = append(o.R.ToAirportQuoteHeaders, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &quoteHeaderR{
				ToAirport: o,
			}
		} else {
			rel.R.ToAirport = o
		}
	}
	return nil
}

// AddFromAirportQuoteOperations adds the given related objects to the existing relationships
// of the airport, optionally inserting them as new records.
// Appends related to o.R.FromAirportQuoteOperations.
// Sets related.R.FromAirport appropriately.
func (o *Airport) AddFromAirportQuoteOperations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*QuoteOperation) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAirportID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"quote_operation\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"from_airport_id"}),
				strmangle.WhereClause("\"", "\"", 2, quoteOperationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAirportID = o.ID
		}
	}

	if o.R == nil {
		o.R = &airportR{
			FromAirportQuoteOperations: related,
		}
	} else {
		o.R.FromAirportQuoteOperations = append(o.R.FromAirportQuoteOperations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &quoteOperationR{
				FromAirport: o,
			}
		} else {
			rel.R.FromAirport = o
		}
	}
	return nil
}

// AddToAirportQuoteOperations adds the given related objects to the existing relationships
// of the airport, optionally inserting them as new records.
// Appends related to o.R.ToAirportQuoteOperations.
// Sets related.R.ToAirport appropriately.
func (o *Airport) AddToAirportQuoteOperations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*QuoteOperation) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToAirportID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"quote_operation\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"to_airport_id"}),
				strmangle.WhereClause("\"", "\"", 2, quoteOperationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToAirportID = o.ID
		}
	}

	if o.R == nil {
		o.R = &airportR{
			ToAirportQuoteOperations: related,
		}
	} else {
		o.R.ToAirportQuoteOperations = append(o.R.ToAirportQuoteOperations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &quoteOperationR{
				ToAirport: o,
			}
		} else {
			rel.R.ToAirport = o
		}
	}
	return nil
}

// Airports retrieves all the records using an executor.
func Airports(mods ...qm.QueryMod) airportQuery {
	mods = append(mods, qm.From("\"airport\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"airport\".*"})
	}

	return airportQuery{q}
}

// FindAirport retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAirport(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Airport, error) {
	airportObj := &Airport{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"airport\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, airportObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from airport")
	}

	if err = airportObj.doAfterSelectHooks(ctx, exec); err != nil {
		return airportObj, err
	}

	return airportObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Airport) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no airport provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(airportColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	airportInsertCacheMut.RLock()
	cache, cached := airportInsertCache[key]
	airportInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			airportAllColumns,
			airportColumnsWithDefault,
			airportColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(airportType, airportMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(airportType, airportMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"airport\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"airport\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into airport")
	}

	if !cached {
		airportInsertCacheMut.Lock()
		airportInsertCache[key] = cache
		airportInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Airport.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Airport) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	airportUpdateCacheMut.RLock()
	cache, cached := airportUpdateCache[key]
	airportUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			airportAllColumns,
			airportPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update airport, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"airport\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, airportPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(airportType, airportMapping, append(wl, airportPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update airport row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for airport")
	}

	if !cached {
		airportUpdateCacheMut.Lock()
		airportUpdateCache[key] = cache
		airportUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q airportQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for airport")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for airport")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AirportSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), airportPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"airport\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, airportPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in airport slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all airport")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Airport) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("dbmodels: no airport provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(airportColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	airportUpsertCacheMut.RLock()
	cache, cached := airportUpsertCache[key]
	airportUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			airportAllColumns,
			airportColumnsWithDefault,
			airportColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			airportAllColumns,
			airportPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert airport, could not build update column list")
		}

		ret := strmangle.SetComplement(airportAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(airportPrimaryKeyColumns) == 0 {
				return errors.New("dbmodels: unable to upsert airport, could not build conflict column list")
			}

			conflict = make([]string, len(airportPrimaryKeyColumns))
			copy(conflict, airportPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"airport\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(airportType, airportMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(airportType, airportMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert airport")
	}

	if !cached {
		airportUpsertCacheMut.Lock()
		airportUpsertCache[key] = cache
		airportUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Airport record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Airport) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no Airport provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), airportPrimaryKeyMapping)
	sql := "DELETE FROM \"airport\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from airport")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for airport")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q airportQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no airportQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from airport")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for airport")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AirportSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(airportBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), airportPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"airport\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, airportPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from airport slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for airport")
	}

	if len(airportAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Airport) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAirport(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AirportSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AirportSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), airportPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"airport\".* FROM \"airport\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, airportPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in AirportSlice")
	}

	*o = slice

	return nil
}

// AirportExists checks if the Airport row exists.
func AirportExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"airport\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if airport exists")
	}

	return exists, nil
}

// Exists checks if the Airport row exists.
func (o *Airport) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return AirportExists(ctx, exec, o.ID)
}
