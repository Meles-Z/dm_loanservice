// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// User is an object representing the database table.
type User struct {
	ID                 int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	Salutation         null.String `boil:"salutation" json:"salutation,omitempty" toml:"salutation" yaml:"salutation,omitempty"`
	FirstName          string      `boil:"first_name" json:"first_name" toml:"first_name" yaml:"first_name"`
	Surname            null.String `boil:"surname" json:"surname,omitempty" toml:"surname" yaml:"surname,omitempty"`
	Email              null.String `boil:"email" json:"email,omitempty" toml:"email" yaml:"email,omitempty"`
	Mobile             null.String `boil:"mobile" json:"mobile,omitempty" toml:"mobile" yaml:"mobile,omitempty"`
	Password           null.String `boil:"password" json:"password,omitempty" toml:"password" yaml:"password,omitempty"`
	Refnumber          null.String `boil:"refnumber" json:"refnumber,omitempty" toml:"refnumber" yaml:"refnumber,omitempty"`
	SubscriptionType   null.String `boil:"subscription_type" json:"subscription_type,omitempty" toml:"subscription_type" yaml:"subscription_type,omitempty"`
	Status             null.String `boil:"status" json:"status,omitempty" toml:"status" yaml:"status,omitempty"`
	CreatedAt          time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	CreatedBy          int         `boil:"created_by" json:"created_by" toml:"created_by" yaml:"created_by"`
	UpdatedAt          null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	UpdatedBy          null.Int    `boil:"updated_by" json:"updated_by,omitempty" toml:"updated_by" yaml:"updated_by,omitempty"`
	MfaEnabled         null.Bool   `boil:"mfa_enabled" json:"mfa_enabled,omitempty" toml:"mfa_enabled" yaml:"mfa_enabled,omitempty"`
	MfaSecret          null.String `boil:"mfa_secret" json:"mfa_secret,omitempty" toml:"mfa_secret" yaml:"mfa_secret,omitempty"`
	BackupCodes        null.String `boil:"backup_codes" json:"backup_codes,omitempty" toml:"backup_codes" yaml:"backup_codes,omitempty"`
	MfaBackupCodesUsed null.String `boil:"mfa_backup_codes_used" json:"mfa_backup_codes_used,omitempty" toml:"mfa_backup_codes_used" yaml:"mfa_backup_codes_used,omitempty"`
	RoleID             null.Int    `boil:"role_id" json:"role_id,omitempty" toml:"role_id" yaml:"role_id,omitempty"`
	TeamID             null.String `boil:"team_id" json:"team_id,omitempty" toml:"team_id" yaml:"team_id,omitempty"`

	R *userR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L userL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UserColumns = struct {
	ID                 string
	Salutation         string
	FirstName          string
	Surname            string
	Email              string
	Mobile             string
	Password           string
	Refnumber          string
	SubscriptionType   string
	Status             string
	CreatedAt          string
	CreatedBy          string
	UpdatedAt          string
	UpdatedBy          string
	MfaEnabled         string
	MfaSecret          string
	BackupCodes        string
	MfaBackupCodesUsed string
	RoleID             string
	TeamID             string
}{
	ID:                 "id",
	Salutation:         "salutation",
	FirstName:          "first_name",
	Surname:            "surname",
	Email:              "email",
	Mobile:             "mobile",
	Password:           "password",
	Refnumber:          "refnumber",
	SubscriptionType:   "subscription_type",
	Status:             "status",
	CreatedAt:          "created_at",
	CreatedBy:          "created_by",
	UpdatedAt:          "updated_at",
	UpdatedBy:          "updated_by",
	MfaEnabled:         "mfa_enabled",
	MfaSecret:          "mfa_secret",
	BackupCodes:        "backup_codes",
	MfaBackupCodesUsed: "mfa_backup_codes_used",
	RoleID:             "role_id",
	TeamID:             "team_id",
}

var UserTableColumns = struct {
	ID                 string
	Salutation         string
	FirstName          string
	Surname            string
	Email              string
	Mobile             string
	Password           string
	Refnumber          string
	SubscriptionType   string
	Status             string
	CreatedAt          string
	CreatedBy          string
	UpdatedAt          string
	UpdatedBy          string
	MfaEnabled         string
	MfaSecret          string
	BackupCodes        string
	MfaBackupCodesUsed string
	RoleID             string
	TeamID             string
}{
	ID:                 "users.id",
	Salutation:         "users.salutation",
	FirstName:          "users.first_name",
	Surname:            "users.surname",
	Email:              "users.email",
	Mobile:             "users.mobile",
	Password:           "users.password",
	Refnumber:          "users.refnumber",
	SubscriptionType:   "users.subscription_type",
	Status:             "users.status",
	CreatedAt:          "users.created_at",
	CreatedBy:          "users.created_by",
	UpdatedAt:          "users.updated_at",
	UpdatedBy:          "users.updated_by",
	MfaEnabled:         "users.mfa_enabled",
	MfaSecret:          "users.mfa_secret",
	BackupCodes:        "users.backup_codes",
	MfaBackupCodesUsed: "users.mfa_backup_codes_used",
	RoleID:             "users.role_id",
	TeamID:             "users.team_id",
}

// Generated where

var UserWhere = struct {
	ID                 whereHelperint
	Salutation         whereHelpernull_String
	FirstName          whereHelperstring
	Surname            whereHelpernull_String
	Email              whereHelpernull_String
	Mobile             whereHelpernull_String
	Password           whereHelpernull_String
	Refnumber          whereHelpernull_String
	SubscriptionType   whereHelpernull_String
	Status             whereHelpernull_String
	CreatedAt          whereHelpertime_Time
	CreatedBy          whereHelperint
	UpdatedAt          whereHelpernull_Time
	UpdatedBy          whereHelpernull_Int
	MfaEnabled         whereHelpernull_Bool
	MfaSecret          whereHelpernull_String
	BackupCodes        whereHelpernull_String
	MfaBackupCodesUsed whereHelpernull_String
	RoleID             whereHelpernull_Int
	TeamID             whereHelpernull_String
}{
	ID:                 whereHelperint{field: "\"users\".\"id\""},
	Salutation:         whereHelpernull_String{field: "\"users\".\"salutation\""},
	FirstName:          whereHelperstring{field: "\"users\".\"first_name\""},
	Surname:            whereHelpernull_String{field: "\"users\".\"surname\""},
	Email:              whereHelpernull_String{field: "\"users\".\"email\""},
	Mobile:             whereHelpernull_String{field: "\"users\".\"mobile\""},
	Password:           whereHelpernull_String{field: "\"users\".\"password\""},
	Refnumber:          whereHelpernull_String{field: "\"users\".\"refnumber\""},
	SubscriptionType:   whereHelpernull_String{field: "\"users\".\"subscription_type\""},
	Status:             whereHelpernull_String{field: "\"users\".\"status\""},
	CreatedAt:          whereHelpertime_Time{field: "\"users\".\"created_at\""},
	CreatedBy:          whereHelperint{field: "\"users\".\"created_by\""},
	UpdatedAt:          whereHelpernull_Time{field: "\"users\".\"updated_at\""},
	UpdatedBy:          whereHelpernull_Int{field: "\"users\".\"updated_by\""},
	MfaEnabled:         whereHelpernull_Bool{field: "\"users\".\"mfa_enabled\""},
	MfaSecret:          whereHelpernull_String{field: "\"users\".\"mfa_secret\""},
	BackupCodes:        whereHelpernull_String{field: "\"users\".\"backup_codes\""},
	MfaBackupCodesUsed: whereHelpernull_String{field: "\"users\".\"mfa_backup_codes_used\""},
	RoleID:             whereHelpernull_Int{field: "\"users\".\"role_id\""},
	TeamID:             whereHelpernull_String{field: "\"users\".\"team_id\""},
}

// UserRels is where relationship names are stored.
var UserRels = struct {
	Role                          string
	Team                          string
	ContactCertifications         string
	AssignedUserCustomerInquiries string
	CreatedByEmptyLegs            string
	FlightComments                string
	FlightsGroups                 string
	CreatedByJourneys             string
	PasswordChanges               string
	ApprovedByPaymentAdjustments  string
	CreatedByPaymentAdjustments   string
	Quotes                        string
	QuoteOperations               string
	QuoteResponses                string
	RepaymentPlanAudits           string
	SearchHistories               string
	AssignedToTasks               string
	UserBackupCodes               string
	UserDetails                   string
	UserDevices                   string
	UserMfaSessions               string
	UserMfaSettings               string
	UserPhotos                    string
	UserTotpSecrets               string
	OwnerWebQueries               string
	OriginatorWebQueryNotes       string
}{
	Role:                          "Role",
	Team:                          "Team",
	ContactCertifications:         "ContactCertifications",
	AssignedUserCustomerInquiries: "AssignedUserCustomerInquiries",
	CreatedByEmptyLegs:            "CreatedByEmptyLegs",
	FlightComments:                "FlightComments",
	FlightsGroups:                 "FlightsGroups",
	CreatedByJourneys:             "CreatedByJourneys",
	PasswordChanges:               "PasswordChanges",
	ApprovedByPaymentAdjustments:  "ApprovedByPaymentAdjustments",
	CreatedByPaymentAdjustments:   "CreatedByPaymentAdjustments",
	Quotes:                        "Quotes",
	QuoteOperations:               "QuoteOperations",
	QuoteResponses:                "QuoteResponses",
	RepaymentPlanAudits:           "RepaymentPlanAudits",
	SearchHistories:               "SearchHistories",
	AssignedToTasks:               "AssignedToTasks",
	UserBackupCodes:               "UserBackupCodes",
	UserDetails:                   "UserDetails",
	UserDevices:                   "UserDevices",
	UserMfaSessions:               "UserMfaSessions",
	UserMfaSettings:               "UserMfaSettings",
	UserPhotos:                    "UserPhotos",
	UserTotpSecrets:               "UserTotpSecrets",
	OwnerWebQueries:               "OwnerWebQueries",
	OriginatorWebQueryNotes:       "OriginatorWebQueryNotes",
}

// userR is where relationships are stored.
type userR struct {
	Role                          *Role                   `boil:"Role" json:"Role" toml:"Role" yaml:"Role"`
	Team                          *Team                   `boil:"Team" json:"Team" toml:"Team" yaml:"Team"`
	ContactCertifications         CertificationSlice      `boil:"ContactCertifications" json:"ContactCertifications" toml:"ContactCertifications" yaml:"ContactCertifications"`
	AssignedUserCustomerInquiries CustomerInquirySlice    `boil:"AssignedUserCustomerInquiries" json:"AssignedUserCustomerInquiries" toml:"AssignedUserCustomerInquiries" yaml:"AssignedUserCustomerInquiries"`
	CreatedByEmptyLegs            EmptyLegSlice           `boil:"CreatedByEmptyLegs" json:"CreatedByEmptyLegs" toml:"CreatedByEmptyLegs" yaml:"CreatedByEmptyLegs"`
	FlightComments                FlightCommentSlice      `boil:"FlightComments" json:"FlightComments" toml:"FlightComments" yaml:"FlightComments"`
	FlightsGroups                 FlightsGroupSlice       `boil:"FlightsGroups" json:"FlightsGroups" toml:"FlightsGroups" yaml:"FlightsGroups"`
	CreatedByJourneys             JourneySlice            `boil:"CreatedByJourneys" json:"CreatedByJourneys" toml:"CreatedByJourneys" yaml:"CreatedByJourneys"`
	PasswordChanges               PasswordChangeSlice     `boil:"PasswordChanges" json:"PasswordChanges" toml:"PasswordChanges" yaml:"PasswordChanges"`
	ApprovedByPaymentAdjustments  PaymentAdjustmentSlice  `boil:"ApprovedByPaymentAdjustments" json:"ApprovedByPaymentAdjustments" toml:"ApprovedByPaymentAdjustments" yaml:"ApprovedByPaymentAdjustments"`
	CreatedByPaymentAdjustments   PaymentAdjustmentSlice  `boil:"CreatedByPaymentAdjustments" json:"CreatedByPaymentAdjustments" toml:"CreatedByPaymentAdjustments" yaml:"CreatedByPaymentAdjustments"`
	Quotes                        QuoteSlice              `boil:"Quotes" json:"Quotes" toml:"Quotes" yaml:"Quotes"`
	QuoteOperations               QuoteOperationSlice     `boil:"QuoteOperations" json:"QuoteOperations" toml:"QuoteOperations" yaml:"QuoteOperations"`
	QuoteResponses                QuoteResponseSlice      `boil:"QuoteResponses" json:"QuoteResponses" toml:"QuoteResponses" yaml:"QuoteResponses"`
	RepaymentPlanAudits           RepaymentPlanAuditSlice `boil:"RepaymentPlanAudits" json:"RepaymentPlanAudits" toml:"RepaymentPlanAudits" yaml:"RepaymentPlanAudits"`
	SearchHistories               SearchHistorySlice      `boil:"SearchHistories" json:"SearchHistories" toml:"SearchHistories" yaml:"SearchHistories"`
	AssignedToTasks               TaskSlice               `boil:"AssignedToTasks" json:"AssignedToTasks" toml:"AssignedToTasks" yaml:"AssignedToTasks"`
	UserBackupCodes               UserBackupCodeSlice     `boil:"UserBackupCodes" json:"UserBackupCodes" toml:"UserBackupCodes" yaml:"UserBackupCodes"`
	UserDetails                   UserDetailSlice         `boil:"UserDetails" json:"UserDetails" toml:"UserDetails" yaml:"UserDetails"`
	UserDevices                   UserDeviceSlice         `boil:"UserDevices" json:"UserDevices" toml:"UserDevices" yaml:"UserDevices"`
	UserMfaSessions               UserMfaSessionSlice     `boil:"UserMfaSessions" json:"UserMfaSessions" toml:"UserMfaSessions" yaml:"UserMfaSessions"`
	UserMfaSettings               UserMfaSettingSlice     `boil:"UserMfaSettings" json:"UserMfaSettings" toml:"UserMfaSettings" yaml:"UserMfaSettings"`
	UserPhotos                    UserPhotoSlice          `boil:"UserPhotos" json:"UserPhotos" toml:"UserPhotos" yaml:"UserPhotos"`
	UserTotpSecrets               UserTotpSecretSlice     `boil:"UserTotpSecrets" json:"UserTotpSecrets" toml:"UserTotpSecrets" yaml:"UserTotpSecrets"`
	OwnerWebQueries               WebQuerySlice           `boil:"OwnerWebQueries" json:"OwnerWebQueries" toml:"OwnerWebQueries" yaml:"OwnerWebQueries"`
	OriginatorWebQueryNotes       WebQueryNoteSlice       `boil:"OriginatorWebQueryNotes" json:"OriginatorWebQueryNotes" toml:"OriginatorWebQueryNotes" yaml:"OriginatorWebQueryNotes"`
}

// NewStruct creates a new relationship struct
func (*userR) NewStruct() *userR {
	return &userR{}
}

func (o *User) GetRole() *Role {
	if o == nil {
		return nil
	}

	return o.R.GetRole()
}

func (r *userR) GetRole() *Role {
	if r == nil {
		return nil
	}

	return r.Role
}

func (o *User) GetTeam() *Team {
	if o == nil {
		return nil
	}

	return o.R.GetTeam()
}

func (r *userR) GetTeam() *Team {
	if r == nil {
		return nil
	}

	return r.Team
}

func (o *User) GetContactCertifications() CertificationSlice {
	if o == nil {
		return nil
	}

	return o.R.GetContactCertifications()
}

func (r *userR) GetContactCertifications() CertificationSlice {
	if r == nil {
		return nil
	}

	return r.ContactCertifications
}

func (o *User) GetAssignedUserCustomerInquiries() CustomerInquirySlice {
	if o == nil {
		return nil
	}

	return o.R.GetAssignedUserCustomerInquiries()
}

func (r *userR) GetAssignedUserCustomerInquiries() CustomerInquirySlice {
	if r == nil {
		return nil
	}

	return r.AssignedUserCustomerInquiries
}

func (o *User) GetCreatedByEmptyLegs() EmptyLegSlice {
	if o == nil {
		return nil
	}

	return o.R.GetCreatedByEmptyLegs()
}

func (r *userR) GetCreatedByEmptyLegs() EmptyLegSlice {
	if r == nil {
		return nil
	}

	return r.CreatedByEmptyLegs
}

func (o *User) GetFlightComments() FlightCommentSlice {
	if o == nil {
		return nil
	}

	return o.R.GetFlightComments()
}

func (r *userR) GetFlightComments() FlightCommentSlice {
	if r == nil {
		return nil
	}

	return r.FlightComments
}

func (o *User) GetFlightsGroups() FlightsGroupSlice {
	if o == nil {
		return nil
	}

	return o.R.GetFlightsGroups()
}

func (r *userR) GetFlightsGroups() FlightsGroupSlice {
	if r == nil {
		return nil
	}

	return r.FlightsGroups
}

func (o *User) GetCreatedByJourneys() JourneySlice {
	if o == nil {
		return nil
	}

	return o.R.GetCreatedByJourneys()
}

func (r *userR) GetCreatedByJourneys() JourneySlice {
	if r == nil {
		return nil
	}

	return r.CreatedByJourneys
}

func (o *User) GetPasswordChanges() PasswordChangeSlice {
	if o == nil {
		return nil
	}

	return o.R.GetPasswordChanges()
}

func (r *userR) GetPasswordChanges() PasswordChangeSlice {
	if r == nil {
		return nil
	}

	return r.PasswordChanges
}

func (o *User) GetApprovedByPaymentAdjustments() PaymentAdjustmentSlice {
	if o == nil {
		return nil
	}

	return o.R.GetApprovedByPaymentAdjustments()
}

func (r *userR) GetApprovedByPaymentAdjustments() PaymentAdjustmentSlice {
	if r == nil {
		return nil
	}

	return r.ApprovedByPaymentAdjustments
}

func (o *User) GetCreatedByPaymentAdjustments() PaymentAdjustmentSlice {
	if o == nil {
		return nil
	}

	return o.R.GetCreatedByPaymentAdjustments()
}

func (r *userR) GetCreatedByPaymentAdjustments() PaymentAdjustmentSlice {
	if r == nil {
		return nil
	}

	return r.CreatedByPaymentAdjustments
}

func (o *User) GetQuotes() QuoteSlice {
	if o == nil {
		return nil
	}

	return o.R.GetQuotes()
}

func (r *userR) GetQuotes() QuoteSlice {
	if r == nil {
		return nil
	}

	return r.Quotes
}

func (o *User) GetQuoteOperations() QuoteOperationSlice {
	if o == nil {
		return nil
	}

	return o.R.GetQuoteOperations()
}

func (r *userR) GetQuoteOperations() QuoteOperationSlice {
	if r == nil {
		return nil
	}

	return r.QuoteOperations
}

func (o *User) GetQuoteResponses() QuoteResponseSlice {
	if o == nil {
		return nil
	}

	return o.R.GetQuoteResponses()
}

func (r *userR) GetQuoteResponses() QuoteResponseSlice {
	if r == nil {
		return nil
	}

	return r.QuoteResponses
}

func (o *User) GetRepaymentPlanAudits() RepaymentPlanAuditSlice {
	if o == nil {
		return nil
	}

	return o.R.GetRepaymentPlanAudits()
}

func (r *userR) GetRepaymentPlanAudits() RepaymentPlanAuditSlice {
	if r == nil {
		return nil
	}

	return r.RepaymentPlanAudits
}

func (o *User) GetSearchHistories() SearchHistorySlice {
	if o == nil {
		return nil
	}

	return o.R.GetSearchHistories()
}

func (r *userR) GetSearchHistories() SearchHistorySlice {
	if r == nil {
		return nil
	}

	return r.SearchHistories
}

func (o *User) GetAssignedToTasks() TaskSlice {
	if o == nil {
		return nil
	}

	return o.R.GetAssignedToTasks()
}

func (r *userR) GetAssignedToTasks() TaskSlice {
	if r == nil {
		return nil
	}

	return r.AssignedToTasks
}

func (o *User) GetUserBackupCodes() UserBackupCodeSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserBackupCodes()
}

func (r *userR) GetUserBackupCodes() UserBackupCodeSlice {
	if r == nil {
		return nil
	}

	return r.UserBackupCodes
}

func (o *User) GetUserDetails() UserDetailSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserDetails()
}

func (r *userR) GetUserDetails() UserDetailSlice {
	if r == nil {
		return nil
	}

	return r.UserDetails
}

func (o *User) GetUserDevices() UserDeviceSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserDevices()
}

func (r *userR) GetUserDevices() UserDeviceSlice {
	if r == nil {
		return nil
	}

	return r.UserDevices
}

func (o *User) GetUserMfaSessions() UserMfaSessionSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserMfaSessions()
}

func (r *userR) GetUserMfaSessions() UserMfaSessionSlice {
	if r == nil {
		return nil
	}

	return r.UserMfaSessions
}

func (o *User) GetUserMfaSettings() UserMfaSettingSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserMfaSettings()
}

func (r *userR) GetUserMfaSettings() UserMfaSettingSlice {
	if r == nil {
		return nil
	}

	return r.UserMfaSettings
}

func (o *User) GetUserPhotos() UserPhotoSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserPhotos()
}

func (r *userR) GetUserPhotos() UserPhotoSlice {
	if r == nil {
		return nil
	}

	return r.UserPhotos
}

func (o *User) GetUserTotpSecrets() UserTotpSecretSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserTotpSecrets()
}

func (r *userR) GetUserTotpSecrets() UserTotpSecretSlice {
	if r == nil {
		return nil
	}

	return r.UserTotpSecrets
}

func (o *User) GetOwnerWebQueries() WebQuerySlice {
	if o == nil {
		return nil
	}

	return o.R.GetOwnerWebQueries()
}

func (r *userR) GetOwnerWebQueries() WebQuerySlice {
	if r == nil {
		return nil
	}

	return r.OwnerWebQueries
}

func (o *User) GetOriginatorWebQueryNotes() WebQueryNoteSlice {
	if o == nil {
		return nil
	}

	return o.R.GetOriginatorWebQueryNotes()
}

func (r *userR) GetOriginatorWebQueryNotes() WebQueryNoteSlice {
	if r == nil {
		return nil
	}

	return r.OriginatorWebQueryNotes
}

// userL is where Load methods for each relationship are stored.
type userL struct{}

var (
	userAllColumns            = []string{"id", "salutation", "first_name", "surname", "email", "mobile", "password", "refnumber", "subscription_type", "status", "created_at", "created_by", "updated_at", "updated_by", "mfa_enabled", "mfa_secret", "backup_codes", "mfa_backup_codes_used", "role_id", "team_id"}
	userColumnsWithoutDefault = []string{"first_name", "created_at", "created_by"}
	userColumnsWithDefault    = []string{"id", "salutation", "surname", "email", "mobile", "password", "refnumber", "subscription_type", "status", "updated_at", "updated_by", "mfa_enabled", "mfa_secret", "backup_codes", "mfa_backup_codes_used", "role_id", "team_id"}
	userPrimaryKeyColumns     = []string{"id"}
	userGeneratedColumns      = []string{}
)

type (
	// UserSlice is an alias for a slice of pointers to User.
	// This should almost always be used instead of []User.
	UserSlice []*User
	// UserHook is the signature for custom User hook methods
	UserHook func(context.Context, boil.ContextExecutor, *User) error

	userQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	userType                 = reflect.TypeOf(&User{})
	userMapping              = queries.MakeStructMapping(userType)
	userPrimaryKeyMapping, _ = queries.BindMapping(userType, userMapping, userPrimaryKeyColumns)
	userInsertCacheMut       sync.RWMutex
	userInsertCache          = make(map[string]insertCache)
	userUpdateCacheMut       sync.RWMutex
	userUpdateCache          = make(map[string]updateCache)
	userUpsertCacheMut       sync.RWMutex
	userUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var userAfterSelectMu sync.Mutex
var userAfterSelectHooks []UserHook

var userBeforeInsertMu sync.Mutex
var userBeforeInsertHooks []UserHook
var userAfterInsertMu sync.Mutex
var userAfterInsertHooks []UserHook

var userBeforeUpdateMu sync.Mutex
var userBeforeUpdateHooks []UserHook
var userAfterUpdateMu sync.Mutex
var userAfterUpdateHooks []UserHook

var userBeforeDeleteMu sync.Mutex
var userBeforeDeleteHooks []UserHook
var userAfterDeleteMu sync.Mutex
var userAfterDeleteHooks []UserHook

var userBeforeUpsertMu sync.Mutex
var userBeforeUpsertHooks []UserHook
var userAfterUpsertMu sync.Mutex
var userAfterUpsertHooks []UserHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *User) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *User) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *User) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *User) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *User) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *User) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *User) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *User) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *User) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddUserHook registers your hook function for all future operations.
func AddUserHook(hookPoint boil.HookPoint, userHook UserHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		userAfterSelectMu.Lock()
		userAfterSelectHooks = append(userAfterSelectHooks, userHook)
		userAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		userBeforeInsertMu.Lock()
		userBeforeInsertHooks = append(userBeforeInsertHooks, userHook)
		userBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		userAfterInsertMu.Lock()
		userAfterInsertHooks = append(userAfterInsertHooks, userHook)
		userAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		userBeforeUpdateMu.Lock()
		userBeforeUpdateHooks = append(userBeforeUpdateHooks, userHook)
		userBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		userAfterUpdateMu.Lock()
		userAfterUpdateHooks = append(userAfterUpdateHooks, userHook)
		userAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		userBeforeDeleteMu.Lock()
		userBeforeDeleteHooks = append(userBeforeDeleteHooks, userHook)
		userBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		userAfterDeleteMu.Lock()
		userAfterDeleteHooks = append(userAfterDeleteHooks, userHook)
		userAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		userBeforeUpsertMu.Lock()
		userBeforeUpsertHooks = append(userBeforeUpsertHooks, userHook)
		userBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		userAfterUpsertMu.Lock()
		userAfterUpsertHooks = append(userAfterUpsertHooks, userHook)
		userAfterUpsertMu.Unlock()
	}
}

// One returns a single user record from the query.
func (q userQuery) One(ctx context.Context, exec boil.ContextExecutor) (*User, error) {
	o := &User{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for users")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all User records from the query.
func (q userQuery) All(ctx context.Context, exec boil.ContextExecutor) (UserSlice, error) {
	var o []*User

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to User slice")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all User records in the query.
func (q userQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count users rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q userQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if users exists")
	}

	return count > 0, nil
}

// Role pointed to by the foreign key.
func (o *User) Role(mods ...qm.QueryMod) roleQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.RoleID),
	}

	queryMods = append(queryMods, mods...)

	return Roles(queryMods...)
}

// Team pointed to by the foreign key.
func (o *User) Team(mods ...qm.QueryMod) teamQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.TeamID),
	}

	queryMods = append(queryMods, mods...)

	return Teams(queryMods...)
}

// ContactCertifications retrieves all the certification's Certifications with an executor via contact_id column.
func (o *User) ContactCertifications(mods ...qm.QueryMod) certificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"certification\".\"contact_id\"=?", o.ID),
	)

	return Certifications(queryMods...)
}

// AssignedUserCustomerInquiries retrieves all the customer_inquiry's CustomerInquiries with an executor via assigned_users_id column.
func (o *User) AssignedUserCustomerInquiries(mods ...qm.QueryMod) customerInquiryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"customer_inquiries\".\"assigned_users_id\"=?", o.ID),
	)

	return CustomerInquiries(queryMods...)
}

// CreatedByEmptyLegs retrieves all the empty_leg's EmptyLegs with an executor via created_by_id column.
func (o *User) CreatedByEmptyLegs(mods ...qm.QueryMod) emptyLegQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"empty_leg\".\"created_by_id\"=?", o.ID),
	)

	return EmptyLegs(queryMods...)
}

// FlightComments retrieves all the flight_comment's FlightComments with an executor.
func (o *User) FlightComments(mods ...qm.QueryMod) flightCommentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"flight_comment\".\"user_id\"=?", o.ID),
	)

	return FlightComments(queryMods...)
}

// FlightsGroups retrieves all the flights_group's FlightsGroups with an executor.
func (o *User) FlightsGroups(mods ...qm.QueryMod) flightsGroupQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"flights_group\".\"user_id\"=?", o.ID),
	)

	return FlightsGroups(queryMods...)
}

// CreatedByJourneys retrieves all the journey's Journeys with an executor via created_by_id column.
func (o *User) CreatedByJourneys(mods ...qm.QueryMod) journeyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"journey\".\"created_by_id\"=?", o.ID),
	)

	return Journeys(queryMods...)
}

// PasswordChanges retrieves all the password_change's PasswordChanges with an executor.
func (o *User) PasswordChanges(mods ...qm.QueryMod) passwordChangeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"password_change\".\"user_id\"=?", o.ID),
	)

	return PasswordChanges(queryMods...)
}

// ApprovedByPaymentAdjustments retrieves all the payment_adjustment's PaymentAdjustments with an executor via approved_by column.
func (o *User) ApprovedByPaymentAdjustments(mods ...qm.QueryMod) paymentAdjustmentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"payment_adjustments\".\"approved_by\"=?", o.ID),
	)

	return PaymentAdjustments(queryMods...)
}

// CreatedByPaymentAdjustments retrieves all the payment_adjustment's PaymentAdjustments with an executor via created_by column.
func (o *User) CreatedByPaymentAdjustments(mods ...qm.QueryMod) paymentAdjustmentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"payment_adjustments\".\"created_by\"=?", o.ID),
	)

	return PaymentAdjustments(queryMods...)
}

// Quotes retrieves all the quote's Quotes with an executor.
func (o *User) Quotes(mods ...qm.QueryMod) quoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"quote\".\"user_id\"=?", o.ID),
	)

	return Quotes(queryMods...)
}

// QuoteOperations retrieves all the quote_operation's QuoteOperations with an executor.
func (o *User) QuoteOperations(mods ...qm.QueryMod) quoteOperationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"quote_operation\".\"user_id\"=?", o.ID),
	)

	return QuoteOperations(queryMods...)
}

// QuoteResponses retrieves all the quote_response's QuoteResponses with an executor.
func (o *User) QuoteResponses(mods ...qm.QueryMod) quoteResponseQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"quote_response\".\"user_id\"=?", o.ID),
	)

	return QuoteResponses(queryMods...)
}

// RepaymentPlanAudits retrieves all the repayment_plan_audit's RepaymentPlanAudits with an executor.
func (o *User) RepaymentPlanAudits(mods ...qm.QueryMod) repaymentPlanAuditQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"repayment_plan_audit\".\"user_id\"=?", o.ID),
	)

	return RepaymentPlanAudits(queryMods...)
}

// SearchHistories retrieves all the search_history's SearchHistories with an executor.
func (o *User) SearchHistories(mods ...qm.QueryMod) searchHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"search_history\".\"user_id\"=?", o.ID),
	)

	return SearchHistories(queryMods...)
}

// AssignedToTasks retrieves all the task's Tasks with an executor via assigned_to column.
func (o *User) AssignedToTasks(mods ...qm.QueryMod) taskQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"tasks\".\"assigned_to\"=?", o.ID),
	)

	return Tasks(queryMods...)
}

// UserBackupCodes retrieves all the user_backup_code's UserBackupCodes with an executor.
func (o *User) UserBackupCodes(mods ...qm.QueryMod) userBackupCodeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_backup_codes\".\"user_id\"=?", o.ID),
	)

	return UserBackupCodes(queryMods...)
}

// UserDetails retrieves all the user_detail's UserDetails with an executor.
func (o *User) UserDetails(mods ...qm.QueryMod) userDetailQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_detail\".\"user_id\"=?", o.ID),
	)

	return UserDetails(queryMods...)
}

// UserDevices retrieves all the user_device's UserDevices with an executor.
func (o *User) UserDevices(mods ...qm.QueryMod) userDeviceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_device\".\"user_id\"=?", o.ID),
	)

	return UserDevices(queryMods...)
}

// UserMfaSessions retrieves all the user_mfa_session's UserMfaSessions with an executor.
func (o *User) UserMfaSessions(mods ...qm.QueryMod) userMfaSessionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_mfa_sessions\".\"user_id\"=?", o.ID),
	)

	return UserMfaSessions(queryMods...)
}

// UserMfaSettings retrieves all the user_mfa_setting's UserMfaSettings with an executor.
func (o *User) UserMfaSettings(mods ...qm.QueryMod) userMfaSettingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_mfa_settings\".\"user_id\"=?", o.ID),
	)

	return UserMfaSettings(queryMods...)
}

// UserPhotos retrieves all the user_photo's UserPhotos with an executor.
func (o *User) UserPhotos(mods ...qm.QueryMod) userPhotoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_photo\".\"user_id\"=?", o.ID),
	)

	return UserPhotos(queryMods...)
}

// UserTotpSecrets retrieves all the user_totp_secret's UserTotpSecrets with an executor.
func (o *User) UserTotpSecrets(mods ...qm.QueryMod) userTotpSecretQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_totp_secrets\".\"user_id\"=?", o.ID),
	)

	return UserTotpSecrets(queryMods...)
}

// OwnerWebQueries retrieves all the web_query's WebQueries with an executor via owner column.
func (o *User) OwnerWebQueries(mods ...qm.QueryMod) webQueryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"web_query\".\"owner\"=?", o.ID),
	)

	return WebQueries(queryMods...)
}

// OriginatorWebQueryNotes retrieves all the web_query_note's WebQueryNotes with an executor via originator_id column.
func (o *User) OriginatorWebQueryNotes(mods ...qm.QueryMod) webQueryNoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"web_query_notes\".\"originator_id\"=?", o.ID),
	)

	return WebQueryNotes(queryMods...)
}

// LoadRole allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadRole(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		if !queries.IsNil(object.RoleID) {
			args[object.RoleID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			if !queries.IsNil(obj.RoleID) {
				args[obj.RoleID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`roles`),
		qm.WhereIn(`roles.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Role")
	}

	var resultSlice []*Role
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Role")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for roles")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for roles")
	}

	if len(roleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Role = foreign
		if foreign.R == nil {
			foreign.R = &roleR{}
		}
		foreign.R.Users = append(foreign.R.Users, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.RoleID, foreign.ID) {
				local.R.Role = foreign
				if foreign.R == nil {
					foreign.R = &roleR{}
				}
				foreign.R.Users = append(foreign.R.Users, local)
				break
			}
		}
	}

	return nil
}

// LoadTeam allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadTeam(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		if !queries.IsNil(object.TeamID) {
			args[object.TeamID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			if !queries.IsNil(obj.TeamID) {
				args[obj.TeamID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`team`),
		qm.WhereIn(`team.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Team")
	}

	var resultSlice []*Team
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Team")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for team")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for team")
	}

	if len(teamAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Team = foreign
		if foreign.R == nil {
			foreign.R = &teamR{}
		}
		foreign.R.Users = append(foreign.R.Users, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.TeamID, foreign.ID) {
				local.R.Team = foreign
				if foreign.R == nil {
					foreign.R = &teamR{}
				}
				foreign.R.Users = append(foreign.R.Users, local)
				break
			}
		}
	}

	return nil
}

// LoadContactCertifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadContactCertifications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`certification`),
		qm.WhereIn(`certification.contact_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load certification")
	}

	var resultSlice []*Certification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice certification")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on certification")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for certification")
	}

	if len(certificationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ContactCertifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &certificationR{}
			}
			foreign.R.Contact = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ContactID {
				local.R.ContactCertifications = append(local.R.ContactCertifications, foreign)
				if foreign.R == nil {
					foreign.R = &certificationR{}
				}
				foreign.R.Contact = local
				break
			}
		}
	}

	return nil
}

// LoadAssignedUserCustomerInquiries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadAssignedUserCustomerInquiries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`customer_inquiries`),
		qm.WhereIn(`customer_inquiries.assigned_users_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load customer_inquiries")
	}

	var resultSlice []*CustomerInquiry
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice customer_inquiries")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on customer_inquiries")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customer_inquiries")
	}

	if len(customerInquiryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AssignedUserCustomerInquiries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerInquiryR{}
			}
			foreign.R.AssignedUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.AssignedUsersID) {
				local.R.AssignedUserCustomerInquiries = append(local.R.AssignedUserCustomerInquiries, foreign)
				if foreign.R == nil {
					foreign.R = &customerInquiryR{}
				}
				foreign.R.AssignedUser = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByEmptyLegs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByEmptyLegs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`empty_leg`),
		qm.WhereIn(`empty_leg.created_by_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load empty_leg")
	}

	var resultSlice []*EmptyLeg
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice empty_leg")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on empty_leg")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for empty_leg")
	}

	if len(emptyLegAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByEmptyLegs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &emptyLegR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatedByID) {
				local.R.CreatedByEmptyLegs = append(local.R.CreatedByEmptyLegs, foreign)
				if foreign.R == nil {
					foreign.R = &emptyLegR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadFlightComments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadFlightComments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`flight_comment`),
		qm.WhereIn(`flight_comment.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load flight_comment")
	}

	var resultSlice []*FlightComment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice flight_comment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on flight_comment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for flight_comment")
	}

	if len(flightCommentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FlightComments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &flightCommentR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserID) {
				local.R.FlightComments = append(local.R.FlightComments, foreign)
				if foreign.R == nil {
					foreign.R = &flightCommentR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadFlightsGroups allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadFlightsGroups(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`flights_group`),
		qm.WhereIn(`flights_group.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load flights_group")
	}

	var resultSlice []*FlightsGroup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice flights_group")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on flights_group")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for flights_group")
	}

	if len(flightsGroupAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FlightsGroups = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &flightsGroupR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserID) {
				local.R.FlightsGroups = append(local.R.FlightsGroups, foreign)
				if foreign.R == nil {
					foreign.R = &flightsGroupR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByJourneys allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByJourneys(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`journey`),
		qm.WhereIn(`journey.created_by_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load journey")
	}

	var resultSlice []*Journey
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice journey")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on journey")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for journey")
	}

	if len(journeyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByJourneys = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &journeyR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatedByID) {
				local.R.CreatedByJourneys = append(local.R.CreatedByJourneys, foreign)
				if foreign.R == nil {
					foreign.R = &journeyR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadPasswordChanges allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadPasswordChanges(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`password_change`),
		qm.WhereIn(`password_change.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load password_change")
	}

	var resultSlice []*PasswordChange
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice password_change")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on password_change")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for password_change")
	}

	if len(passwordChangeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PasswordChanges = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &passwordChangeR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.PasswordChanges = append(local.R.PasswordChanges, foreign)
				if foreign.R == nil {
					foreign.R = &passwordChangeR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadApprovedByPaymentAdjustments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadApprovedByPaymentAdjustments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`payment_adjustments`),
		qm.WhereIn(`payment_adjustments.approved_by in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load payment_adjustments")
	}

	var resultSlice []*PaymentAdjustment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice payment_adjustments")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on payment_adjustments")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for payment_adjustments")
	}

	if len(paymentAdjustmentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ApprovedByPaymentAdjustments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentAdjustmentR{}
			}
			foreign.R.ApprovedByUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ApprovedBy) {
				local.R.ApprovedByPaymentAdjustments = append(local.R.ApprovedByPaymentAdjustments, foreign)
				if foreign.R == nil {
					foreign.R = &paymentAdjustmentR{}
				}
				foreign.R.ApprovedByUser = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByPaymentAdjustments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByPaymentAdjustments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`payment_adjustments`),
		qm.WhereIn(`payment_adjustments.created_by in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load payment_adjustments")
	}

	var resultSlice []*PaymentAdjustment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice payment_adjustments")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on payment_adjustments")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for payment_adjustments")
	}

	if len(paymentAdjustmentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByPaymentAdjustments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentAdjustmentR{}
			}
			foreign.R.CreatedByUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CreatedBy {
				local.R.CreatedByPaymentAdjustments = append(local.R.CreatedByPaymentAdjustments, foreign)
				if foreign.R == nil {
					foreign.R = &paymentAdjustmentR{}
				}
				foreign.R.CreatedByUser = local
				break
			}
		}
	}

	return nil
}

// LoadQuotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadQuotes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`quote`),
		qm.WhereIn(`quote.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load quote")
	}

	var resultSlice []*Quote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice quote")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on quote")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quote")
	}

	if len(quoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Quotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &quoteR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.Quotes = append(local.R.Quotes, foreign)
				if foreign.R == nil {
					foreign.R = &quoteR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadQuoteOperations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadQuoteOperations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`quote_operation`),
		qm.WhereIn(`quote_operation.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load quote_operation")
	}

	var resultSlice []*QuoteOperation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice quote_operation")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on quote_operation")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quote_operation")
	}

	if len(quoteOperationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.QuoteOperations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &quoteOperationR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.QuoteOperations = append(local.R.QuoteOperations, foreign)
				if foreign.R == nil {
					foreign.R = &quoteOperationR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadQuoteResponses allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadQuoteResponses(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`quote_response`),
		qm.WhereIn(`quote_response.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load quote_response")
	}

	var resultSlice []*QuoteResponse
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice quote_response")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on quote_response")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quote_response")
	}

	if len(quoteResponseAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.QuoteResponses = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &quoteResponseR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.QuoteResponses = append(local.R.QuoteResponses, foreign)
				if foreign.R == nil {
					foreign.R = &quoteResponseR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadRepaymentPlanAudits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadRepaymentPlanAudits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`repayment_plan_audit`),
		qm.WhereIn(`repayment_plan_audit.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load repayment_plan_audit")
	}

	var resultSlice []*RepaymentPlanAudit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice repayment_plan_audit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on repayment_plan_audit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for repayment_plan_audit")
	}

	if len(repaymentPlanAuditAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RepaymentPlanAudits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &repaymentPlanAuditR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.RepaymentPlanAudits = append(local.R.RepaymentPlanAudits, foreign)
				if foreign.R == nil {
					foreign.R = &repaymentPlanAuditR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadSearchHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadSearchHistories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`search_history`),
		qm.WhereIn(`search_history.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load search_history")
	}

	var resultSlice []*SearchHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice search_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on search_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for search_history")
	}

	if len(searchHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SearchHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &searchHistoryR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.SearchHistories = append(local.R.SearchHistories, foreign)
				if foreign.R == nil {
					foreign.R = &searchHistoryR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadAssignedToTasks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadAssignedToTasks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`tasks`),
		qm.WhereIn(`tasks.assigned_to in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load tasks")
	}

	var resultSlice []*Task
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice tasks")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on tasks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for tasks")
	}

	if len(taskAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AssignedToTasks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &taskR{}
			}
			foreign.R.AssignedToUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.AssignedTo) {
				local.R.AssignedToTasks = append(local.R.AssignedToTasks, foreign)
				if foreign.R == nil {
					foreign.R = &taskR{}
				}
				foreign.R.AssignedToUser = local
				break
			}
		}
	}

	return nil
}

// LoadUserBackupCodes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserBackupCodes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_backup_codes`),
		qm.WhereIn(`user_backup_codes.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_backup_codes")
	}

	var resultSlice []*UserBackupCode
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_backup_codes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_backup_codes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_backup_codes")
	}

	if len(userBackupCodeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserBackupCodes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userBackupCodeR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserBackupCodes = append(local.R.UserBackupCodes, foreign)
				if foreign.R == nil {
					foreign.R = &userBackupCodeR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserDetails allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserDetails(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_detail`),
		qm.WhereIn(`user_detail.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_detail")
	}

	var resultSlice []*UserDetail
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_detail")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_detail")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_detail")
	}

	if len(userDetailAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserDetails = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userDetailR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserDetails = append(local.R.UserDetails, foreign)
				if foreign.R == nil {
					foreign.R = &userDetailR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserDevices allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserDevices(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_device`),
		qm.WhereIn(`user_device.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_device")
	}

	var resultSlice []*UserDevice
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_device")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_device")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_device")
	}

	if len(userDeviceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserDevices = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userDeviceR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserDevices = append(local.R.UserDevices, foreign)
				if foreign.R == nil {
					foreign.R = &userDeviceR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserMfaSessions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserMfaSessions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_mfa_sessions`),
		qm.WhereIn(`user_mfa_sessions.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_mfa_sessions")
	}

	var resultSlice []*UserMfaSession
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_mfa_sessions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_mfa_sessions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_mfa_sessions")
	}

	if len(userMfaSessionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserMfaSessions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userMfaSessionR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserMfaSessions = append(local.R.UserMfaSessions, foreign)
				if foreign.R == nil {
					foreign.R = &userMfaSessionR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserMfaSettings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserMfaSettings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_mfa_settings`),
		qm.WhereIn(`user_mfa_settings.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_mfa_settings")
	}

	var resultSlice []*UserMfaSetting
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_mfa_settings")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_mfa_settings")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_mfa_settings")
	}

	if len(userMfaSettingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserMfaSettings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userMfaSettingR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserMfaSettings = append(local.R.UserMfaSettings, foreign)
				if foreign.R == nil {
					foreign.R = &userMfaSettingR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserPhotos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserPhotos(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_photo`),
		qm.WhereIn(`user_photo.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_photo")
	}

	var resultSlice []*UserPhoto
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_photo")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_photo")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_photo")
	}

	if len(userPhotoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserPhotos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userPhotoR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserPhotos = append(local.R.UserPhotos, foreign)
				if foreign.R == nil {
					foreign.R = &userPhotoR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserTotpSecrets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserTotpSecrets(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_totp_secrets`),
		qm.WhereIn(`user_totp_secrets.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_totp_secrets")
	}

	var resultSlice []*UserTotpSecret
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_totp_secrets")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_totp_secrets")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_totp_secrets")
	}

	if len(userTotpSecretAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserTotpSecrets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userTotpSecretR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserTotpSecrets = append(local.R.UserTotpSecrets, foreign)
				if foreign.R == nil {
					foreign.R = &userTotpSecretR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerWebQueries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadOwnerWebQueries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`web_query`),
		qm.WhereIn(`web_query.owner in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load web_query")
	}

	var resultSlice []*WebQuery
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice web_query")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on web_query")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for web_query")
	}

	if len(webQueryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerWebQueries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &webQueryR{}
			}
			foreign.R.OwnerUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Owner) {
				local.R.OwnerWebQueries = append(local.R.OwnerWebQueries, foreign)
				if foreign.R == nil {
					foreign.R = &webQueryR{}
				}
				foreign.R.OwnerUser = local
				break
			}
		}
	}

	return nil
}

// LoadOriginatorWebQueryNotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadOriginatorWebQueryNotes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`web_query_notes`),
		qm.WhereIn(`web_query_notes.originator_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load web_query_notes")
	}

	var resultSlice []*WebQueryNote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice web_query_notes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on web_query_notes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for web_query_notes")
	}

	if len(webQueryNoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OriginatorWebQueryNotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &webQueryNoteR{}
			}
			foreign.R.Originator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OriginatorID {
				local.R.OriginatorWebQueryNotes = append(local.R.OriginatorWebQueryNotes, foreign)
				if foreign.R == nil {
					foreign.R = &webQueryNoteR{}
				}
				foreign.R.Originator = local
				break
			}
		}
	}

	return nil
}

// SetRole of the user to the related item.
// Sets o.R.Role to related.
// Adds o to related.R.Users.
func (o *User) SetRole(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Role) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"role_id"}),
		strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.RoleID, related.ID)
	if o.R == nil {
		o.R = &userR{
			Role: related,
		}
	} else {
		o.R.Role = related
	}

	if related.R == nil {
		related.R = &roleR{
			Users: UserSlice{o},
		}
	} else {
		related.R.Users = append(related.R.Users, o)
	}

	return nil
}

// RemoveRole relationship.
// Sets o.R.Role to nil.
// Removes o from all passed in related items' relationships struct.
func (o *User) RemoveRole(ctx context.Context, exec boil.ContextExecutor, related *Role) error {
	var err error

	queries.SetScanner(&o.RoleID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("role_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Role = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Users {
		if queries.Equal(o.RoleID, ri.RoleID) {
			continue
		}

		ln := len(related.R.Users)
		if ln > 1 && i < ln-1 {
			related.R.Users[i] = related.R.Users[ln-1]
		}
		related.R.Users = related.R.Users[:ln-1]
		break
	}
	return nil
}

// SetTeam of the user to the related item.
// Sets o.R.Team to related.
// Adds o to related.R.Users.
func (o *User) SetTeam(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Team) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"team_id"}),
		strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.TeamID, related.ID)
	if o.R == nil {
		o.R = &userR{
			Team: related,
		}
	} else {
		o.R.Team = related
	}

	if related.R == nil {
		related.R = &teamR{
			Users: UserSlice{o},
		}
	} else {
		related.R.Users = append(related.R.Users, o)
	}

	return nil
}

// RemoveTeam relationship.
// Sets o.R.Team to nil.
// Removes o from all passed in related items' relationships struct.
func (o *User) RemoveTeam(ctx context.Context, exec boil.ContextExecutor, related *Team) error {
	var err error

	queries.SetScanner(&o.TeamID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("team_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Team = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Users {
		if queries.Equal(o.TeamID, ri.TeamID) {
			continue
		}

		ln := len(related.R.Users)
		if ln > 1 && i < ln-1 {
			related.R.Users[i] = related.R.Users[ln-1]
		}
		related.R.Users = related.R.Users[:ln-1]
		break
	}
	return nil
}

// AddContactCertifications adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ContactCertifications.
// Sets related.R.Contact appropriately.
func (o *User) AddContactCertifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Certification) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ContactID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"certification\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"contact_id"}),
				strmangle.WhereClause("\"", "\"", 2, certificationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ContactID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ContactCertifications: related,
		}
	} else {
		o.R.ContactCertifications = append(o.R.ContactCertifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &certificationR{
				Contact: o,
			}
		} else {
			rel.R.Contact = o
		}
	}
	return nil
}

// AddAssignedUserCustomerInquiries adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.AssignedUserCustomerInquiries.
// Sets related.R.AssignedUser appropriately.
func (o *User) AddAssignedUserCustomerInquiries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerInquiry) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AssignedUsersID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"customer_inquiries\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"assigned_users_id"}),
				strmangle.WhereClause("\"", "\"", 2, customerInquiryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AssignedUsersID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			AssignedUserCustomerInquiries: related,
		}
	} else {
		o.R.AssignedUserCustomerInquiries = append(o.R.AssignedUserCustomerInquiries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerInquiryR{
				AssignedUser: o,
			}
		} else {
			rel.R.AssignedUser = o
		}
	}
	return nil
}

// SetAssignedUserCustomerInquiries removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.AssignedUser's AssignedUserCustomerInquiries accordingly.
// Replaces o.R.AssignedUserCustomerInquiries with related.
// Sets related.R.AssignedUser's AssignedUserCustomerInquiries accordingly.
func (o *User) SetAssignedUserCustomerInquiries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerInquiry) error {
	query := "update \"customer_inquiries\" set \"assigned_users_id\" = null where \"assigned_users_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.AssignedUserCustomerInquiries {
			queries.SetScanner(&rel.AssignedUsersID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.AssignedUser = nil
		}
		o.R.AssignedUserCustomerInquiries = nil
	}

	return o.AddAssignedUserCustomerInquiries(ctx, exec, insert, related...)
}

// RemoveAssignedUserCustomerInquiries relationships from objects passed in.
// Removes related items from R.AssignedUserCustomerInquiries (uses pointer comparison, removal does not keep order)
// Sets related.R.AssignedUser.
func (o *User) RemoveAssignedUserCustomerInquiries(ctx context.Context, exec boil.ContextExecutor, related ...*CustomerInquiry) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AssignedUsersID, nil)
		if rel.R != nil {
			rel.R.AssignedUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("assigned_users_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.AssignedUserCustomerInquiries {
			if rel != ri {
				continue
			}

			ln := len(o.R.AssignedUserCustomerInquiries)
			if ln > 1 && i < ln-1 {
				o.R.AssignedUserCustomerInquiries[i] = o.R.AssignedUserCustomerInquiries[ln-1]
			}
			o.R.AssignedUserCustomerInquiries = o.R.AssignedUserCustomerInquiries[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatedByEmptyLegs adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByEmptyLegs.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByEmptyLegs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*EmptyLeg) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatedByID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"empty_leg\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, emptyLegPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatedByID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByEmptyLegs: related,
		}
	} else {
		o.R.CreatedByEmptyLegs = append(o.R.CreatedByEmptyLegs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &emptyLegR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// SetCreatedByEmptyLegs removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.CreatedBy's CreatedByEmptyLegs accordingly.
// Replaces o.R.CreatedByEmptyLegs with related.
// Sets related.R.CreatedBy's CreatedByEmptyLegs accordingly.
func (o *User) SetCreatedByEmptyLegs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*EmptyLeg) error {
	query := "update \"empty_leg\" set \"created_by_id\" = null where \"created_by_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatedByEmptyLegs {
			queries.SetScanner(&rel.CreatedByID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.CreatedBy = nil
		}
		o.R.CreatedByEmptyLegs = nil
	}

	return o.AddCreatedByEmptyLegs(ctx, exec, insert, related...)
}

// RemoveCreatedByEmptyLegs relationships from objects passed in.
// Removes related items from R.CreatedByEmptyLegs (uses pointer comparison, removal does not keep order)
// Sets related.R.CreatedBy.
func (o *User) RemoveCreatedByEmptyLegs(ctx context.Context, exec boil.ContextExecutor, related ...*EmptyLeg) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatedByID, nil)
		if rel.R != nil {
			rel.R.CreatedBy = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("created_by_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatedByEmptyLegs {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatedByEmptyLegs)
			if ln > 1 && i < ln-1 {
				o.R.CreatedByEmptyLegs[i] = o.R.CreatedByEmptyLegs[ln-1]
			}
			o.R.CreatedByEmptyLegs = o.R.CreatedByEmptyLegs[:ln-1]
			break
		}
	}

	return nil
}

// AddFlightComments adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.FlightComments.
// Sets related.R.User appropriately.
func (o *User) AddFlightComments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FlightComment) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"flight_comment\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, flightCommentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			FlightComments: related,
		}
	} else {
		o.R.FlightComments = append(o.R.FlightComments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &flightCommentR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// SetFlightComments removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.User's FlightComments accordingly.
// Replaces o.R.FlightComments with related.
// Sets related.R.User's FlightComments accordingly.
func (o *User) SetFlightComments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FlightComment) error {
	query := "update \"flight_comment\" set \"user_id\" = null where \"user_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.FlightComments {
			queries.SetScanner(&rel.UserID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.User = nil
		}
		o.R.FlightComments = nil
	}

	return o.AddFlightComments(ctx, exec, insert, related...)
}

// RemoveFlightComments relationships from objects passed in.
// Removes related items from R.FlightComments (uses pointer comparison, removal does not keep order)
// Sets related.R.User.
func (o *User) RemoveFlightComments(ctx context.Context, exec boil.ContextExecutor, related ...*FlightComment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserID, nil)
		if rel.R != nil {
			rel.R.User = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("user_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FlightComments {
			if rel != ri {
				continue
			}

			ln := len(o.R.FlightComments)
			if ln > 1 && i < ln-1 {
				o.R.FlightComments[i] = o.R.FlightComments[ln-1]
			}
			o.R.FlightComments = o.R.FlightComments[:ln-1]
			break
		}
	}

	return nil
}

// AddFlightsGroups adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.FlightsGroups.
// Sets related.R.User appropriately.
func (o *User) AddFlightsGroups(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FlightsGroup) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"flights_group\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, flightsGroupPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			FlightsGroups: related,
		}
	} else {
		o.R.FlightsGroups = append(o.R.FlightsGroups, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &flightsGroupR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// SetFlightsGroups removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.User's FlightsGroups accordingly.
// Replaces o.R.FlightsGroups with related.
// Sets related.R.User's FlightsGroups accordingly.
func (o *User) SetFlightsGroups(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FlightsGroup) error {
	query := "update \"flights_group\" set \"user_id\" = null where \"user_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.FlightsGroups {
			queries.SetScanner(&rel.UserID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.User = nil
		}
		o.R.FlightsGroups = nil
	}

	return o.AddFlightsGroups(ctx, exec, insert, related...)
}

// RemoveFlightsGroups relationships from objects passed in.
// Removes related items from R.FlightsGroups (uses pointer comparison, removal does not keep order)
// Sets related.R.User.
func (o *User) RemoveFlightsGroups(ctx context.Context, exec boil.ContextExecutor, related ...*FlightsGroup) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserID, nil)
		if rel.R != nil {
			rel.R.User = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("user_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FlightsGroups {
			if rel != ri {
				continue
			}

			ln := len(o.R.FlightsGroups)
			if ln > 1 && i < ln-1 {
				o.R.FlightsGroups[i] = o.R.FlightsGroups[ln-1]
			}
			o.R.FlightsGroups = o.R.FlightsGroups[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatedByJourneys adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByJourneys.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByJourneys(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Journey) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatedByID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"journey\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, journeyPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatedByID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByJourneys: related,
		}
	} else {
		o.R.CreatedByJourneys = append(o.R.CreatedByJourneys, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &journeyR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// SetCreatedByJourneys removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.CreatedBy's CreatedByJourneys accordingly.
// Replaces o.R.CreatedByJourneys with related.
// Sets related.R.CreatedBy's CreatedByJourneys accordingly.
func (o *User) SetCreatedByJourneys(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Journey) error {
	query := "update \"journey\" set \"created_by_id\" = null where \"created_by_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatedByJourneys {
			queries.SetScanner(&rel.CreatedByID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.CreatedBy = nil
		}
		o.R.CreatedByJourneys = nil
	}

	return o.AddCreatedByJourneys(ctx, exec, insert, related...)
}

// RemoveCreatedByJourneys relationships from objects passed in.
// Removes related items from R.CreatedByJourneys (uses pointer comparison, removal does not keep order)
// Sets related.R.CreatedBy.
func (o *User) RemoveCreatedByJourneys(ctx context.Context, exec boil.ContextExecutor, related ...*Journey) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatedByID, nil)
		if rel.R != nil {
			rel.R.CreatedBy = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("created_by_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatedByJourneys {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatedByJourneys)
			if ln > 1 && i < ln-1 {
				o.R.CreatedByJourneys[i] = o.R.CreatedByJourneys[ln-1]
			}
			o.R.CreatedByJourneys = o.R.CreatedByJourneys[:ln-1]
			break
		}
	}

	return nil
}

// AddPasswordChanges adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.PasswordChanges.
// Sets related.R.User appropriately.
func (o *User) AddPasswordChanges(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PasswordChange) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"password_change\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, passwordChangePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			PasswordChanges: related,
		}
	} else {
		o.R.PasswordChanges = append(o.R.PasswordChanges, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &passwordChangeR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddApprovedByPaymentAdjustments adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ApprovedByPaymentAdjustments.
// Sets related.R.ApprovedByUser appropriately.
func (o *User) AddApprovedByPaymentAdjustments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentAdjustment) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ApprovedBy, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"payment_adjustments\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"approved_by"}),
				strmangle.WhereClause("\"", "\"", 2, paymentAdjustmentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ApprovedBy, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			ApprovedByPaymentAdjustments: related,
		}
	} else {
		o.R.ApprovedByPaymentAdjustments = append(o.R.ApprovedByPaymentAdjustments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentAdjustmentR{
				ApprovedByUser: o,
			}
		} else {
			rel.R.ApprovedByUser = o
		}
	}
	return nil
}

// SetApprovedByPaymentAdjustments removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ApprovedByUser's ApprovedByPaymentAdjustments accordingly.
// Replaces o.R.ApprovedByPaymentAdjustments with related.
// Sets related.R.ApprovedByUser's ApprovedByPaymentAdjustments accordingly.
func (o *User) SetApprovedByPaymentAdjustments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentAdjustment) error {
	query := "update \"payment_adjustments\" set \"approved_by\" = null where \"approved_by\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ApprovedByPaymentAdjustments {
			queries.SetScanner(&rel.ApprovedBy, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ApprovedByUser = nil
		}
		o.R.ApprovedByPaymentAdjustments = nil
	}

	return o.AddApprovedByPaymentAdjustments(ctx, exec, insert, related...)
}

// RemoveApprovedByPaymentAdjustments relationships from objects passed in.
// Removes related items from R.ApprovedByPaymentAdjustments (uses pointer comparison, removal does not keep order)
// Sets related.R.ApprovedByUser.
func (o *User) RemoveApprovedByPaymentAdjustments(ctx context.Context, exec boil.ContextExecutor, related ...*PaymentAdjustment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ApprovedBy, nil)
		if rel.R != nil {
			rel.R.ApprovedByUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("approved_by")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ApprovedByPaymentAdjustments {
			if rel != ri {
				continue
			}

			ln := len(o.R.ApprovedByPaymentAdjustments)
			if ln > 1 && i < ln-1 {
				o.R.ApprovedByPaymentAdjustments[i] = o.R.ApprovedByPaymentAdjustments[ln-1]
			}
			o.R.ApprovedByPaymentAdjustments = o.R.ApprovedByPaymentAdjustments[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatedByPaymentAdjustments adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByPaymentAdjustments.
// Sets related.R.CreatedByUser appropriately.
func (o *User) AddCreatedByPaymentAdjustments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentAdjustment) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CreatedBy = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"payment_adjustments\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by"}),
				strmangle.WhereClause("\"", "\"", 2, paymentAdjustmentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CreatedBy = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByPaymentAdjustments: related,
		}
	} else {
		o.R.CreatedByPaymentAdjustments = append(o.R.CreatedByPaymentAdjustments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentAdjustmentR{
				CreatedByUser: o,
			}
		} else {
			rel.R.CreatedByUser = o
		}
	}
	return nil
}

// AddQuotes adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.Quotes.
// Sets related.R.User appropriately.
func (o *User) AddQuotes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Quote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"quote\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			Quotes: related,
		}
	} else {
		o.R.Quotes = append(o.R.Quotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &quoteR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddQuoteOperations adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.QuoteOperations.
// Sets related.R.User appropriately.
func (o *User) AddQuoteOperations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*QuoteOperation) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"quote_operation\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, quoteOperationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			QuoteOperations: related,
		}
	} else {
		o.R.QuoteOperations = append(o.R.QuoteOperations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &quoteOperationR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddQuoteResponses adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.QuoteResponses.
// Sets related.R.User appropriately.
func (o *User) AddQuoteResponses(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*QuoteResponse) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"quote_response\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, quoteResponsePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			QuoteResponses: related,
		}
	} else {
		o.R.QuoteResponses = append(o.R.QuoteResponses, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &quoteResponseR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddRepaymentPlanAudits adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.RepaymentPlanAudits.
// Sets related.R.User appropriately.
func (o *User) AddRepaymentPlanAudits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RepaymentPlanAudit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"repayment_plan_audit\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, repaymentPlanAuditPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			RepaymentPlanAudits: related,
		}
	} else {
		o.R.RepaymentPlanAudits = append(o.R.RepaymentPlanAudits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &repaymentPlanAuditR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddSearchHistories adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.SearchHistories.
// Sets related.R.User appropriately.
func (o *User) AddSearchHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SearchHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"search_history\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, searchHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			SearchHistories: related,
		}
	} else {
		o.R.SearchHistories = append(o.R.SearchHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &searchHistoryR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddAssignedToTasks adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.AssignedToTasks.
// Sets related.R.AssignedToUser appropriately.
func (o *User) AddAssignedToTasks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Task) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AssignedTo, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"tasks\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"assigned_to"}),
				strmangle.WhereClause("\"", "\"", 2, taskPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AssignedTo, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			AssignedToTasks: related,
		}
	} else {
		o.R.AssignedToTasks = append(o.R.AssignedToTasks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &taskR{
				AssignedToUser: o,
			}
		} else {
			rel.R.AssignedToUser = o
		}
	}
	return nil
}

// SetAssignedToTasks removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.AssignedToUser's AssignedToTasks accordingly.
// Replaces o.R.AssignedToTasks with related.
// Sets related.R.AssignedToUser's AssignedToTasks accordingly.
func (o *User) SetAssignedToTasks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Task) error {
	query := "update \"tasks\" set \"assigned_to\" = null where \"assigned_to\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.AssignedToTasks {
			queries.SetScanner(&rel.AssignedTo, nil)
			if rel.R == nil {
				continue
			}

			rel.R.AssignedToUser = nil
		}
		o.R.AssignedToTasks = nil
	}

	return o.AddAssignedToTasks(ctx, exec, insert, related...)
}

// RemoveAssignedToTasks relationships from objects passed in.
// Removes related items from R.AssignedToTasks (uses pointer comparison, removal does not keep order)
// Sets related.R.AssignedToUser.
func (o *User) RemoveAssignedToTasks(ctx context.Context, exec boil.ContextExecutor, related ...*Task) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AssignedTo, nil)
		if rel.R != nil {
			rel.R.AssignedToUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("assigned_to")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.AssignedToTasks {
			if rel != ri {
				continue
			}

			ln := len(o.R.AssignedToTasks)
			if ln > 1 && i < ln-1 {
				o.R.AssignedToTasks[i] = o.R.AssignedToTasks[ln-1]
			}
			o.R.AssignedToTasks = o.R.AssignedToTasks[:ln-1]
			break
		}
	}

	return nil
}

// AddUserBackupCodes adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserBackupCodes.
// Sets related.R.User appropriately.
func (o *User) AddUserBackupCodes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserBackupCode) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_backup_codes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userBackupCodePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserBackupCodes: related,
		}
	} else {
		o.R.UserBackupCodes = append(o.R.UserBackupCodes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userBackupCodeR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserDetails adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserDetails.
// Sets related.R.User appropriately.
func (o *User) AddUserDetails(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserDetail) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_detail\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userDetailPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserDetails: related,
		}
	} else {
		o.R.UserDetails = append(o.R.UserDetails, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userDetailR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserDevices adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserDevices.
// Sets related.R.User appropriately.
func (o *User) AddUserDevices(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserDevice) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_device\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userDevicePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserDevices: related,
		}
	} else {
		o.R.UserDevices = append(o.R.UserDevices, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userDeviceR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserMfaSessions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserMfaSessions.
// Sets related.R.User appropriately.
func (o *User) AddUserMfaSessions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserMfaSession) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_mfa_sessions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userMfaSessionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserMfaSessions: related,
		}
	} else {
		o.R.UserMfaSessions = append(o.R.UserMfaSessions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userMfaSessionR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserMfaSettings adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserMfaSettings.
// Sets related.R.User appropriately.
func (o *User) AddUserMfaSettings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserMfaSetting) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_mfa_settings\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userMfaSettingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserMfaSettings: related,
		}
	} else {
		o.R.UserMfaSettings = append(o.R.UserMfaSettings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userMfaSettingR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserPhotos adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserPhotos.
// Sets related.R.User appropriately.
func (o *User) AddUserPhotos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserPhoto) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_photo\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userPhotoPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserPhotos: related,
		}
	} else {
		o.R.UserPhotos = append(o.R.UserPhotos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userPhotoR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserTotpSecrets adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserTotpSecrets.
// Sets related.R.User appropriately.
func (o *User) AddUserTotpSecrets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserTotpSecret) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_totp_secrets\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userTotpSecretPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserTotpSecrets: related,
		}
	} else {
		o.R.UserTotpSecrets = append(o.R.UserTotpSecrets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userTotpSecretR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddOwnerWebQueries adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.OwnerWebQueries.
// Sets related.R.OwnerUser appropriately.
func (o *User) AddOwnerWebQueries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*WebQuery) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Owner, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"web_query\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner"}),
				strmangle.WhereClause("\"", "\"", 2, webQueryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Owner, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			OwnerWebQueries: related,
		}
	} else {
		o.R.OwnerWebQueries = append(o.R.OwnerWebQueries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &webQueryR{
				OwnerUser: o,
			}
		} else {
			rel.R.OwnerUser = o
		}
	}
	return nil
}

// SetOwnerWebQueries removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OwnerUser's OwnerWebQueries accordingly.
// Replaces o.R.OwnerWebQueries with related.
// Sets related.R.OwnerUser's OwnerWebQueries accordingly.
func (o *User) SetOwnerWebQueries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*WebQuery) error {
	query := "update \"web_query\" set \"owner\" = null where \"owner\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.OwnerWebQueries {
			queries.SetScanner(&rel.Owner, nil)
			if rel.R == nil {
				continue
			}

			rel.R.OwnerUser = nil
		}
		o.R.OwnerWebQueries = nil
	}

	return o.AddOwnerWebQueries(ctx, exec, insert, related...)
}

// RemoveOwnerWebQueries relationships from objects passed in.
// Removes related items from R.OwnerWebQueries (uses pointer comparison, removal does not keep order)
// Sets related.R.OwnerUser.
func (o *User) RemoveOwnerWebQueries(ctx context.Context, exec boil.ContextExecutor, related ...*WebQuery) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Owner, nil)
		if rel.R != nil {
			rel.R.OwnerUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("owner")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OwnerWebQueries {
			if rel != ri {
				continue
			}

			ln := len(o.R.OwnerWebQueries)
			if ln > 1 && i < ln-1 {
				o.R.OwnerWebQueries[i] = o.R.OwnerWebQueries[ln-1]
			}
			o.R.OwnerWebQueries = o.R.OwnerWebQueries[:ln-1]
			break
		}
	}

	return nil
}

// AddOriginatorWebQueryNotes adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.OriginatorWebQueryNotes.
// Sets related.R.Originator appropriately.
func (o *User) AddOriginatorWebQueryNotes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*WebQueryNote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OriginatorID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"web_query_notes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"originator_id"}),
				strmangle.WhereClause("\"", "\"", 2, webQueryNotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OriginatorID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			OriginatorWebQueryNotes: related,
		}
	} else {
		o.R.OriginatorWebQueryNotes = append(o.R.OriginatorWebQueryNotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &webQueryNoteR{
				Originator: o,
			}
		} else {
			rel.R.Originator = o
		}
	}
	return nil
}

// Users retrieves all the records using an executor.
func Users(mods ...qm.QueryMod) userQuery {
	mods = append(mods, qm.From("\"users\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"users\".*"})
	}

	return userQuery{q}
}

// FindUser retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUser(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*User, error) {
	userObj := &User{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"users\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, userObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from users")
	}

	if err = userObj.doAfterSelectHooks(ctx, exec); err != nil {
		return userObj, err
	}

	return userObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *User) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no users provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	userInsertCacheMut.RLock()
	cache, cached := userInsertCache[key]
	userInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(userType, userMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"users\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"users\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into users")
	}

	if !cached {
		userInsertCacheMut.Lock()
		userInsertCache[key] = cache
		userInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the User.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *User) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	userUpdateCacheMut.RLock()
	cache, cached := userUpdateCache[key]
	userUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update users, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"users\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, userPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(userType, userMapping, append(wl, userPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update users row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for users")
	}

	if !cached {
		userUpdateCacheMut.Lock()
		userUpdateCache[key] = cache
		userUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q userQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for users")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UserSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, userPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all user")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *User) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("dbmodels: no users provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	userUpsertCacheMut.RLock()
	cache, cached := userUpsertCache[key]
	userUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert users, could not build update column list")
		}

		ret := strmangle.SetComplement(userAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(userPrimaryKeyColumns) == 0 {
				return errors.New("dbmodels: unable to upsert users, could not build conflict column list")
			}

			conflict = make([]string, len(userPrimaryKeyColumns))
			copy(conflict, userPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"users\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(userType, userMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert users")
	}

	if !cached {
		userUpsertCacheMut.Lock()
		userUpsertCache[key] = cache
		userUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single User record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *User) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no User provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userPrimaryKeyMapping)
	sql := "DELETE FROM \"users\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for users")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q userQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no userQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for users")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UserSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(userBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"users\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for users")
	}

	if len(userAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *User) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindUser(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UserSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"users\".* FROM \"users\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in UserSlice")
	}

	*o = slice

	return nil
}

// UserExists checks if the User row exists.
func UserExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"users\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if users exists")
	}

	return exists, nil
}

// Exists checks if the User row exists.
func (o *User) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return UserExists(ctx, exec, o.ID)
}
