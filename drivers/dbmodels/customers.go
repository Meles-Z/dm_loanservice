// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// Customer is an object representing the database table.
type Customer struct {
	ID                       string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	CustomerType             string      `boil:"customer_type" json:"customer_type" toml:"customer_type" yaml:"customer_type"`
	FirstName                string      `boil:"first_name" json:"first_name" toml:"first_name" yaml:"first_name"`
	LastName                 string      `boil:"last_name" json:"last_name" toml:"last_name" yaml:"last_name"`
	DateOfBirth              time.Time   `boil:"date_of_birth" json:"date_of_birth" toml:"date_of_birth" yaml:"date_of_birth"`
	PlaceOfBirth             null.String `boil:"place_of_birth" json:"place_of_birth,omitempty" toml:"place_of_birth" yaml:"place_of_birth,omitempty"`
	Gender                   null.String `boil:"gender" json:"gender,omitempty" toml:"gender" yaml:"gender,omitempty"`
	Nationality              null.String `boil:"nationality" json:"nationality,omitempty" toml:"nationality" yaml:"nationality,omitempty"`
	NationalInsuranceNo      null.String `boil:"national_insurance_no" json:"national_insurance_no,omitempty" toml:"national_insurance_no" yaml:"national_insurance_no,omitempty"`
	Email                    null.String `boil:"email" json:"email,omitempty" toml:"email" yaml:"email,omitempty"`
	Phone                    null.String `boil:"phone" json:"phone,omitempty" toml:"phone" yaml:"phone,omitempty"`
	Address                  null.String `boil:"address" json:"address,omitempty" toml:"address" yaml:"address,omitempty"`
	RiskProfile              null.String `boil:"risk_profile" json:"risk_profile,omitempty" toml:"risk_profile" yaml:"risk_profile,omitempty"`
	FraudFlag                null.Bool   `boil:"fraud_flag" json:"fraud_flag,omitempty" toml:"fraud_flag" yaml:"fraud_flag,omitempty"`
	FraudNotes               null.String `boil:"fraud_notes" json:"fraud_notes,omitempty" toml:"fraud_notes" yaml:"fraud_notes,omitempty"`
	KycCheckStatus           null.String `boil:"kyc_check_status" json:"kyc_check_status,omitempty" toml:"kyc_check_status" yaml:"kyc_check_status,omitempty"`
	AmlFlag                  null.Bool   `boil:"aml_flag" json:"aml_flag,omitempty" toml:"aml_flag" yaml:"aml_flag,omitempty"`
	PoliticallyExposedPerson null.Bool   `boil:"politically_exposed_person" json:"politically_exposed_person,omitempty" toml:"politically_exposed_person" yaml:"politically_exposed_person,omitempty"`
	VulnerabilityFlag        null.Bool   `boil:"vulnerability_flag" json:"vulnerability_flag,omitempty" toml:"vulnerability_flag" yaml:"vulnerability_flag,omitempty"`
	ConsentFlag              null.Bool   `boil:"consent_flag" json:"consent_flag,omitempty" toml:"consent_flag" yaml:"consent_flag,omitempty"`
	ConsentWithdrawalDate    null.Time   `boil:"consent_withdrawal_date" json:"consent_withdrawal_date,omitempty" toml:"consent_withdrawal_date" yaml:"consent_withdrawal_date,omitempty"`
	CreatedAt                null.Time   `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt                null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt                null.Time   `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`

	R *customerR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L customerL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CustomerColumns = struct {
	ID                       string
	CustomerType             string
	FirstName                string
	LastName                 string
	DateOfBirth              string
	PlaceOfBirth             string
	Gender                   string
	Nationality              string
	NationalInsuranceNo      string
	Email                    string
	Phone                    string
	Address                  string
	RiskProfile              string
	FraudFlag                string
	FraudNotes               string
	KycCheckStatus           string
	AmlFlag                  string
	PoliticallyExposedPerson string
	VulnerabilityFlag        string
	ConsentFlag              string
	ConsentWithdrawalDate    string
	CreatedAt                string
	UpdatedAt                string
	DeletedAt                string
}{
	ID:                       "id",
	CustomerType:             "customer_type",
	FirstName:                "first_name",
	LastName:                 "last_name",
	DateOfBirth:              "date_of_birth",
	PlaceOfBirth:             "place_of_birth",
	Gender:                   "gender",
	Nationality:              "nationality",
	NationalInsuranceNo:      "national_insurance_no",
	Email:                    "email",
	Phone:                    "phone",
	Address:                  "address",
	RiskProfile:              "risk_profile",
	FraudFlag:                "fraud_flag",
	FraudNotes:               "fraud_notes",
	KycCheckStatus:           "kyc_check_status",
	AmlFlag:                  "aml_flag",
	PoliticallyExposedPerson: "politically_exposed_person",
	VulnerabilityFlag:        "vulnerability_flag",
	ConsentFlag:              "consent_flag",
	ConsentWithdrawalDate:    "consent_withdrawal_date",
	CreatedAt:                "created_at",
	UpdatedAt:                "updated_at",
	DeletedAt:                "deleted_at",
}

var CustomerTableColumns = struct {
	ID                       string
	CustomerType             string
	FirstName                string
	LastName                 string
	DateOfBirth              string
	PlaceOfBirth             string
	Gender                   string
	Nationality              string
	NationalInsuranceNo      string
	Email                    string
	Phone                    string
	Address                  string
	RiskProfile              string
	FraudFlag                string
	FraudNotes               string
	KycCheckStatus           string
	AmlFlag                  string
	PoliticallyExposedPerson string
	VulnerabilityFlag        string
	ConsentFlag              string
	ConsentWithdrawalDate    string
	CreatedAt                string
	UpdatedAt                string
	DeletedAt                string
}{
	ID:                       "customers.id",
	CustomerType:             "customers.customer_type",
	FirstName:                "customers.first_name",
	LastName:                 "customers.last_name",
	DateOfBirth:              "customers.date_of_birth",
	PlaceOfBirth:             "customers.place_of_birth",
	Gender:                   "customers.gender",
	Nationality:              "customers.nationality",
	NationalInsuranceNo:      "customers.national_insurance_no",
	Email:                    "customers.email",
	Phone:                    "customers.phone",
	Address:                  "customers.address",
	RiskProfile:              "customers.risk_profile",
	FraudFlag:                "customers.fraud_flag",
	FraudNotes:               "customers.fraud_notes",
	KycCheckStatus:           "customers.kyc_check_status",
	AmlFlag:                  "customers.aml_flag",
	PoliticallyExposedPerson: "customers.politically_exposed_person",
	VulnerabilityFlag:        "customers.vulnerability_flag",
	ConsentFlag:              "customers.consent_flag",
	ConsentWithdrawalDate:    "customers.consent_withdrawal_date",
	CreatedAt:                "customers.created_at",
	UpdatedAt:                "customers.updated_at",
	DeletedAt:                "customers.deleted_at",
}

// Generated where

var CustomerWhere = struct {
	ID                       whereHelperstring
	CustomerType             whereHelperstring
	FirstName                whereHelperstring
	LastName                 whereHelperstring
	DateOfBirth              whereHelpertime_Time
	PlaceOfBirth             whereHelpernull_String
	Gender                   whereHelpernull_String
	Nationality              whereHelpernull_String
	NationalInsuranceNo      whereHelpernull_String
	Email                    whereHelpernull_String
	Phone                    whereHelpernull_String
	Address                  whereHelpernull_String
	RiskProfile              whereHelpernull_String
	FraudFlag                whereHelpernull_Bool
	FraudNotes               whereHelpernull_String
	KycCheckStatus           whereHelpernull_String
	AmlFlag                  whereHelpernull_Bool
	PoliticallyExposedPerson whereHelpernull_Bool
	VulnerabilityFlag        whereHelpernull_Bool
	ConsentFlag              whereHelpernull_Bool
	ConsentWithdrawalDate    whereHelpernull_Time
	CreatedAt                whereHelpernull_Time
	UpdatedAt                whereHelpernull_Time
	DeletedAt                whereHelpernull_Time
}{
	ID:                       whereHelperstring{field: "\"customers\".\"id\""},
	CustomerType:             whereHelperstring{field: "\"customers\".\"customer_type\""},
	FirstName:                whereHelperstring{field: "\"customers\".\"first_name\""},
	LastName:                 whereHelperstring{field: "\"customers\".\"last_name\""},
	DateOfBirth:              whereHelpertime_Time{field: "\"customers\".\"date_of_birth\""},
	PlaceOfBirth:             whereHelpernull_String{field: "\"customers\".\"place_of_birth\""},
	Gender:                   whereHelpernull_String{field: "\"customers\".\"gender\""},
	Nationality:              whereHelpernull_String{field: "\"customers\".\"nationality\""},
	NationalInsuranceNo:      whereHelpernull_String{field: "\"customers\".\"national_insurance_no\""},
	Email:                    whereHelpernull_String{field: "\"customers\".\"email\""},
	Phone:                    whereHelpernull_String{field: "\"customers\".\"phone\""},
	Address:                  whereHelpernull_String{field: "\"customers\".\"address\""},
	RiskProfile:              whereHelpernull_String{field: "\"customers\".\"risk_profile\""},
	FraudFlag:                whereHelpernull_Bool{field: "\"customers\".\"fraud_flag\""},
	FraudNotes:               whereHelpernull_String{field: "\"customers\".\"fraud_notes\""},
	KycCheckStatus:           whereHelpernull_String{field: "\"customers\".\"kyc_check_status\""},
	AmlFlag:                  whereHelpernull_Bool{field: "\"customers\".\"aml_flag\""},
	PoliticallyExposedPerson: whereHelpernull_Bool{field: "\"customers\".\"politically_exposed_person\""},
	VulnerabilityFlag:        whereHelpernull_Bool{field: "\"customers\".\"vulnerability_flag\""},
	ConsentFlag:              whereHelpernull_Bool{field: "\"customers\".\"consent_flag\""},
	ConsentWithdrawalDate:    whereHelpernull_Time{field: "\"customers\".\"consent_withdrawal_date\""},
	CreatedAt:                whereHelpernull_Time{field: "\"customers\".\"created_at\""},
	UpdatedAt:                whereHelpernull_Time{field: "\"customers\".\"updated_at\""},
	DeletedAt:                whereHelpernull_Time{field: "\"customers\".\"deleted_at\""},
}

// CustomerRels is where relationship names are stored.
var CustomerRels = struct {
	Accounts          string
	CustomerInquiries string
	Kycs              string
	Tasks             string
}{
	Accounts:          "Accounts",
	CustomerInquiries: "CustomerInquiries",
	Kycs:              "Kycs",
	Tasks:             "Tasks",
}

// customerR is where relationships are stored.
type customerR struct {
	Accounts          AccountSlice         `boil:"Accounts" json:"Accounts" toml:"Accounts" yaml:"Accounts"`
	CustomerInquiries CustomerInquirySlice `boil:"CustomerInquiries" json:"CustomerInquiries" toml:"CustomerInquiries" yaml:"CustomerInquiries"`
	Kycs              KycSlice             `boil:"Kycs" json:"Kycs" toml:"Kycs" yaml:"Kycs"`
	Tasks             TaskSlice            `boil:"Tasks" json:"Tasks" toml:"Tasks" yaml:"Tasks"`
}

// NewStruct creates a new relationship struct
func (*customerR) NewStruct() *customerR {
	return &customerR{}
}

func (o *Customer) GetAccounts() AccountSlice {
	if o == nil {
		return nil
	}

	return o.R.GetAccounts()
}

func (r *customerR) GetAccounts() AccountSlice {
	if r == nil {
		return nil
	}

	return r.Accounts
}

func (o *Customer) GetCustomerInquiries() CustomerInquirySlice {
	if o == nil {
		return nil
	}

	return o.R.GetCustomerInquiries()
}

func (r *customerR) GetCustomerInquiries() CustomerInquirySlice {
	if r == nil {
		return nil
	}

	return r.CustomerInquiries
}

func (o *Customer) GetKycs() KycSlice {
	if o == nil {
		return nil
	}

	return o.R.GetKycs()
}

func (r *customerR) GetKycs() KycSlice {
	if r == nil {
		return nil
	}

	return r.Kycs
}

func (o *Customer) GetTasks() TaskSlice {
	if o == nil {
		return nil
	}

	return o.R.GetTasks()
}

func (r *customerR) GetTasks() TaskSlice {
	if r == nil {
		return nil
	}

	return r.Tasks
}

// customerL is where Load methods for each relationship are stored.
type customerL struct{}

var (
	customerAllColumns            = []string{"id", "customer_type", "first_name", "last_name", "date_of_birth", "place_of_birth", "gender", "nationality", "national_insurance_no", "email", "phone", "address", "risk_profile", "fraud_flag", "fraud_notes", "kyc_check_status", "aml_flag", "politically_exposed_person", "vulnerability_flag", "consent_flag", "consent_withdrawal_date", "created_at", "updated_at", "deleted_at"}
	customerColumnsWithoutDefault = []string{"id", "customer_type", "first_name", "last_name", "date_of_birth"}
	customerColumnsWithDefault    = []string{"place_of_birth", "gender", "nationality", "national_insurance_no", "email", "phone", "address", "risk_profile", "fraud_flag", "fraud_notes", "kyc_check_status", "aml_flag", "politically_exposed_person", "vulnerability_flag", "consent_flag", "consent_withdrawal_date", "created_at", "updated_at", "deleted_at"}
	customerPrimaryKeyColumns     = []string{"id"}
	customerGeneratedColumns      = []string{}
)

type (
	// CustomerSlice is an alias for a slice of pointers to Customer.
	// This should almost always be used instead of []Customer.
	CustomerSlice []*Customer
	// CustomerHook is the signature for custom Customer hook methods
	CustomerHook func(context.Context, boil.ContextExecutor, *Customer) error

	customerQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	customerType                 = reflect.TypeOf(&Customer{})
	customerMapping              = queries.MakeStructMapping(customerType)
	customerPrimaryKeyMapping, _ = queries.BindMapping(customerType, customerMapping, customerPrimaryKeyColumns)
	customerInsertCacheMut       sync.RWMutex
	customerInsertCache          = make(map[string]insertCache)
	customerUpdateCacheMut       sync.RWMutex
	customerUpdateCache          = make(map[string]updateCache)
	customerUpsertCacheMut       sync.RWMutex
	customerUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var customerAfterSelectMu sync.Mutex
var customerAfterSelectHooks []CustomerHook

var customerBeforeInsertMu sync.Mutex
var customerBeforeInsertHooks []CustomerHook
var customerAfterInsertMu sync.Mutex
var customerAfterInsertHooks []CustomerHook

var customerBeforeUpdateMu sync.Mutex
var customerBeforeUpdateHooks []CustomerHook
var customerAfterUpdateMu sync.Mutex
var customerAfterUpdateHooks []CustomerHook

var customerBeforeDeleteMu sync.Mutex
var customerBeforeDeleteHooks []CustomerHook
var customerAfterDeleteMu sync.Mutex
var customerAfterDeleteHooks []CustomerHook

var customerBeforeUpsertMu sync.Mutex
var customerBeforeUpsertHooks []CustomerHook
var customerAfterUpsertMu sync.Mutex
var customerAfterUpsertHooks []CustomerHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Customer) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Customer) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Customer) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Customer) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Customer) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Customer) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Customer) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Customer) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Customer) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCustomerHook registers your hook function for all future operations.
func AddCustomerHook(hookPoint boil.HookPoint, customerHook CustomerHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		customerAfterSelectMu.Lock()
		customerAfterSelectHooks = append(customerAfterSelectHooks, customerHook)
		customerAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		customerBeforeInsertMu.Lock()
		customerBeforeInsertHooks = append(customerBeforeInsertHooks, customerHook)
		customerBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		customerAfterInsertMu.Lock()
		customerAfterInsertHooks = append(customerAfterInsertHooks, customerHook)
		customerAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		customerBeforeUpdateMu.Lock()
		customerBeforeUpdateHooks = append(customerBeforeUpdateHooks, customerHook)
		customerBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		customerAfterUpdateMu.Lock()
		customerAfterUpdateHooks = append(customerAfterUpdateHooks, customerHook)
		customerAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		customerBeforeDeleteMu.Lock()
		customerBeforeDeleteHooks = append(customerBeforeDeleteHooks, customerHook)
		customerBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		customerAfterDeleteMu.Lock()
		customerAfterDeleteHooks = append(customerAfterDeleteHooks, customerHook)
		customerAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		customerBeforeUpsertMu.Lock()
		customerBeforeUpsertHooks = append(customerBeforeUpsertHooks, customerHook)
		customerBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		customerAfterUpsertMu.Lock()
		customerAfterUpsertHooks = append(customerAfterUpsertHooks, customerHook)
		customerAfterUpsertMu.Unlock()
	}
}

// One returns a single customer record from the query.
func (q customerQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Customer, error) {
	o := &Customer{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for customers")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Customer records from the query.
func (q customerQuery) All(ctx context.Context, exec boil.ContextExecutor) (CustomerSlice, error) {
	var o []*Customer

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to Customer slice")
	}

	if len(customerAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Customer records in the query.
func (q customerQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count customers rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q customerQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if customers exists")
	}

	return count > 0, nil
}

// Accounts retrieves all the account's Accounts with an executor.
func (o *Customer) Accounts(mods ...qm.QueryMod) accountQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"accounts\".\"customer_id\"=?", o.ID),
	)

	return Accounts(queryMods...)
}

// CustomerInquiries retrieves all the customer_inquiry's CustomerInquiries with an executor.
func (o *Customer) CustomerInquiries(mods ...qm.QueryMod) customerInquiryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"customer_inquiries\".\"customer_id\"=?", o.ID),
	)

	return CustomerInquiries(queryMods...)
}

// Kycs retrieves all the kyc's Kycs with an executor.
func (o *Customer) Kycs(mods ...qm.QueryMod) kycQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"kyc\".\"customer_id\"=?", o.ID),
	)

	return Kycs(queryMods...)
}

// Tasks retrieves all the task's Tasks with an executor.
func (o *Customer) Tasks(mods ...qm.QueryMod) taskQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"tasks\".\"customer_id\"=?", o.ID),
	)

	return Tasks(queryMods...)
}

// LoadAccounts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (customerL) LoadAccounts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomer interface{}, mods queries.Applicator) error {
	var slice []*Customer
	var object *Customer

	if singular {
		var ok bool
		object, ok = maybeCustomer.(*Customer)
		if !ok {
			object = new(Customer)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCustomer))
			}
		}
	} else {
		s, ok := maybeCustomer.(*[]*Customer)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCustomer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &customerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`accounts`),
		qm.WhereIn(`accounts.customer_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load accounts")
	}

	var resultSlice []*Account
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice accounts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on accounts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for accounts")
	}

	if len(accountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Accounts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CustomerID {
				local.R.Accounts = append(local.R.Accounts, foreign)
				if foreign.R == nil {
					foreign.R = &accountR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// LoadCustomerInquiries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (customerL) LoadCustomerInquiries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomer interface{}, mods queries.Applicator) error {
	var slice []*Customer
	var object *Customer

	if singular {
		var ok bool
		object, ok = maybeCustomer.(*Customer)
		if !ok {
			object = new(Customer)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCustomer))
			}
		}
	} else {
		s, ok := maybeCustomer.(*[]*Customer)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCustomer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &customerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`customer_inquiries`),
		qm.WhereIn(`customer_inquiries.customer_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load customer_inquiries")
	}

	var resultSlice []*CustomerInquiry
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice customer_inquiries")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on customer_inquiries")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customer_inquiries")
	}

	if len(customerInquiryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CustomerInquiries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerInquiryR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CustomerID {
				local.R.CustomerInquiries = append(local.R.CustomerInquiries, foreign)
				if foreign.R == nil {
					foreign.R = &customerInquiryR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// LoadKycs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (customerL) LoadKycs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomer interface{}, mods queries.Applicator) error {
	var slice []*Customer
	var object *Customer

	if singular {
		var ok bool
		object, ok = maybeCustomer.(*Customer)
		if !ok {
			object = new(Customer)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCustomer))
			}
		}
	} else {
		s, ok := maybeCustomer.(*[]*Customer)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCustomer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &customerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`kyc`),
		qm.WhereIn(`kyc.customer_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load kyc")
	}

	var resultSlice []*Kyc
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice kyc")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on kyc")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for kyc")
	}

	if len(kycAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Kycs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &kycR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CustomerID) {
				local.R.Kycs = append(local.R.Kycs, foreign)
				if foreign.R == nil {
					foreign.R = &kycR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// LoadTasks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (customerL) LoadTasks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomer interface{}, mods queries.Applicator) error {
	var slice []*Customer
	var object *Customer

	if singular {
		var ok bool
		object, ok = maybeCustomer.(*Customer)
		if !ok {
			object = new(Customer)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCustomer))
			}
		}
	} else {
		s, ok := maybeCustomer.(*[]*Customer)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCustomer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &customerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`tasks`),
		qm.WhereIn(`tasks.customer_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load tasks")
	}

	var resultSlice []*Task
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice tasks")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on tasks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for tasks")
	}

	if len(taskAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Tasks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &taskR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CustomerID {
				local.R.Tasks = append(local.R.Tasks, foreign)
				if foreign.R == nil {
					foreign.R = &taskR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// AddAccounts adds the given related objects to the existing relationships
// of the customer, optionally inserting them as new records.
// Appends related to o.R.Accounts.
// Sets related.R.Customer appropriately.
func (o *Customer) AddAccounts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Account) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CustomerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"accounts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"customer_id"}),
				strmangle.WhereClause("\"", "\"", 2, accountPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CustomerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &customerR{
			Accounts: related,
		}
	} else {
		o.R.Accounts = append(o.R.Accounts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// AddCustomerInquiries adds the given related objects to the existing relationships
// of the customer, optionally inserting them as new records.
// Appends related to o.R.CustomerInquiries.
// Sets related.R.Customer appropriately.
func (o *Customer) AddCustomerInquiries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerInquiry) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CustomerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"customer_inquiries\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"customer_id"}),
				strmangle.WhereClause("\"", "\"", 2, customerInquiryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CustomerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &customerR{
			CustomerInquiries: related,
		}
	} else {
		o.R.CustomerInquiries = append(o.R.CustomerInquiries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerInquiryR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// AddKycs adds the given related objects to the existing relationships
// of the customer, optionally inserting them as new records.
// Appends related to o.R.Kycs.
// Sets related.R.Customer appropriately.
func (o *Customer) AddKycs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Kyc) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CustomerID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"kyc\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"customer_id"}),
				strmangle.WhereClause("\"", "\"", 2, kycPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CustomerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &customerR{
			Kycs: related,
		}
	} else {
		o.R.Kycs = append(o.R.Kycs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &kycR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// SetKycs removes all previously related items of the
// customer replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Customer's Kycs accordingly.
// Replaces o.R.Kycs with related.
// Sets related.R.Customer's Kycs accordingly.
func (o *Customer) SetKycs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Kyc) error {
	query := "update \"kyc\" set \"customer_id\" = null where \"customer_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Kycs {
			queries.SetScanner(&rel.CustomerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Customer = nil
		}
		o.R.Kycs = nil
	}

	return o.AddKycs(ctx, exec, insert, related...)
}

// RemoveKycs relationships from objects passed in.
// Removes related items from R.Kycs (uses pointer comparison, removal does not keep order)
// Sets related.R.Customer.
func (o *Customer) RemoveKycs(ctx context.Context, exec boil.ContextExecutor, related ...*Kyc) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CustomerID, nil)
		if rel.R != nil {
			rel.R.Customer = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("customer_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Kycs {
			if rel != ri {
				continue
			}

			ln := len(o.R.Kycs)
			if ln > 1 && i < ln-1 {
				o.R.Kycs[i] = o.R.Kycs[ln-1]
			}
			o.R.Kycs = o.R.Kycs[:ln-1]
			break
		}
	}

	return nil
}

// AddTasks adds the given related objects to the existing relationships
// of the customer, optionally inserting them as new records.
// Appends related to o.R.Tasks.
// Sets related.R.Customer appropriately.
func (o *Customer) AddTasks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Task) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CustomerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"tasks\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"customer_id"}),
				strmangle.WhereClause("\"", "\"", 2, taskPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CustomerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &customerR{
			Tasks: related,
		}
	} else {
		o.R.Tasks = append(o.R.Tasks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &taskR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// Customers retrieves all the records using an executor.
func Customers(mods ...qm.QueryMod) customerQuery {
	mods = append(mods, qm.From("\"customers\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"customers\".*"})
	}

	return customerQuery{q}
}

// FindCustomer retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCustomer(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Customer, error) {
	customerObj := &Customer{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"customers\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, customerObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from customers")
	}

	if err = customerObj.doAfterSelectHooks(ctx, exec); err != nil {
		return customerObj, err
	}

	return customerObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Customer) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no customers provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(customerColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	customerInsertCacheMut.RLock()
	cache, cached := customerInsertCache[key]
	customerInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			customerAllColumns,
			customerColumnsWithDefault,
			customerColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(customerType, customerMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(customerType, customerMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"customers\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"customers\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into customers")
	}

	if !cached {
		customerInsertCacheMut.Lock()
		customerInsertCache[key] = cache
		customerInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Customer.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Customer) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	customerUpdateCacheMut.RLock()
	cache, cached := customerUpdateCache[key]
	customerUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			customerAllColumns,
			customerPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update customers, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"customers\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, customerPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(customerType, customerMapping, append(wl, customerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update customers row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for customers")
	}

	if !cached {
		customerUpdateCacheMut.Lock()
		customerUpdateCache[key] = cache
		customerUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q customerQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for customers")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for customers")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CustomerSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), customerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"customers\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, customerPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in customer slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all customer")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Customer) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("dbmodels: no customers provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(customerColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	customerUpsertCacheMut.RLock()
	cache, cached := customerUpsertCache[key]
	customerUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			customerAllColumns,
			customerColumnsWithDefault,
			customerColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			customerAllColumns,
			customerPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert customers, could not build update column list")
		}

		ret := strmangle.SetComplement(customerAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(customerPrimaryKeyColumns) == 0 {
				return errors.New("dbmodels: unable to upsert customers, could not build conflict column list")
			}

			conflict = make([]string, len(customerPrimaryKeyColumns))
			copy(conflict, customerPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"customers\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(customerType, customerMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(customerType, customerMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert customers")
	}

	if !cached {
		customerUpsertCacheMut.Lock()
		customerUpsertCache[key] = cache
		customerUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Customer record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Customer) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no Customer provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), customerPrimaryKeyMapping)
	sql := "DELETE FROM \"customers\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from customers")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for customers")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q customerQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no customerQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from customers")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for customers")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CustomerSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(customerBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), customerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"customers\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, customerPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from customer slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for customers")
	}

	if len(customerAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Customer) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCustomer(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CustomerSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CustomerSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), customerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"customers\".* FROM \"customers\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, customerPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in CustomerSlice")
	}

	*o = slice

	return nil
}

// CustomerExists checks if the Customer row exists.
func CustomerExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"customers\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if customers exists")
	}

	return exists, nil
}

// Exists checks if the Customer row exists.
func (o *Customer) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return CustomerExists(ctx, exec, o.ID)
}
