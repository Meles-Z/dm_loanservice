// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// Account is an object representing the database table.
type Account struct {
	ID                  string            `boil:"id" json:"id" toml:"id" yaml:"id"`
	CustomerID          string            `boil:"customer_id" json:"customer_id" toml:"customer_id" yaml:"customer_id"`
	ProductID           string            `boil:"product_id" json:"product_id" toml:"product_id" yaml:"product_id"`
	LoanAmount          types.Decimal     `boil:"loan_amount" json:"loan_amount" toml:"loan_amount" yaml:"loan_amount"`
	BalanceOutstanding  types.Decimal     `boil:"balance_outstanding" json:"balance_outstanding" toml:"balance_outstanding" yaml:"balance_outstanding"`
	StartDate           time.Time         `boil:"start_date" json:"start_date" toml:"start_date" yaml:"start_date"`
	EndDate             time.Time         `boil:"end_date" json:"end_date" toml:"end_date" yaml:"end_date"`
	TermYears           int               `boil:"term_years" json:"term_years" toml:"term_years" yaml:"term_years"`
	ArrearsFlag         null.Bool         `boil:"arrears_flag" json:"arrears_flag,omitempty" toml:"arrears_flag" yaml:"arrears_flag,omitempty"`
	ArrearsAmount       types.NullDecimal `boil:"arrears_amount" json:"arrears_amount,omitempty" toml:"arrears_amount" yaml:"arrears_amount,omitempty"`
	ArrearsDays         null.Int          `boil:"arrears_days" json:"arrears_days,omitempty" toml:"arrears_days" yaml:"arrears_days,omitempty"`
	ForbearanceFlag     null.Bool         `boil:"forbearance_flag" json:"forbearance_flag,omitempty" toml:"forbearance_flag" yaml:"forbearance_flag,omitempty"`
	ForbearanceType     null.String       `boil:"forbearance_type" json:"forbearance_type,omitempty" toml:"forbearance_type" yaml:"forbearance_type,omitempty"`
	FraudFlag           null.Bool         `boil:"fraud_flag" json:"fraud_flag,omitempty" toml:"fraud_flag" yaml:"fraud_flag,omitempty"`
	FraudNotes          null.String       `boil:"fraud_notes" json:"fraud_notes,omitempty" toml:"fraud_notes" yaml:"fraud_notes,omitempty"`
	RedrawFacility      null.Bool         `boil:"redraw_facility" json:"redraw_facility,omitempty" toml:"redraw_facility" yaml:"redraw_facility,omitempty"`
	CollateralAddress   null.String       `boil:"collateral_address" json:"collateral_address,omitempty" toml:"collateral_address" yaml:"collateral_address,omitempty"`
	CollateralType      null.String       `boil:"collateral_type" json:"collateral_type,omitempty" toml:"collateral_type" yaml:"collateral_type,omitempty"`
	SecurityType        null.String       `boil:"security_type" json:"security_type,omitempty" toml:"security_type" yaml:"security_type,omitempty"`
	PortfolioID         null.String       `boil:"portfolio_id" json:"portfolio_id,omitempty" toml:"portfolio_id" yaml:"portfolio_id,omitempty"`
	StressTestResult    null.String       `boil:"stress_test_result" json:"stress_test_result,omitempty" toml:"stress_test_result" yaml:"stress_test_result,omitempty"`
	CapitalAdequacyFlag null.Bool         `boil:"capital_adequacy_flag" json:"capital_adequacy_flag,omitempty" toml:"capital_adequacy_flag" yaml:"capital_adequacy_flag,omitempty"`
	CreatedAt           null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt           null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt           null.Time         `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	LastPaymentAmount   types.NullDecimal `boil:"last_payment_amount" json:"last_payment_amount,omitempty" toml:"last_payment_amount" yaml:"last_payment_amount,omitempty"`
	LastPaymentDate     null.Time         `boil:"last_payment_date" json:"last_payment_date,omitempty" toml:"last_payment_date" yaml:"last_payment_date,omitempty"`
	Status              string            `boil:"status" json:"status" toml:"status" yaml:"status"`

	R *accountR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L accountL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AccountColumns = struct {
	ID                  string
	CustomerID          string
	ProductID           string
	LoanAmount          string
	BalanceOutstanding  string
	StartDate           string
	EndDate             string
	TermYears           string
	ArrearsFlag         string
	ArrearsAmount       string
	ArrearsDays         string
	ForbearanceFlag     string
	ForbearanceType     string
	FraudFlag           string
	FraudNotes          string
	RedrawFacility      string
	CollateralAddress   string
	CollateralType      string
	SecurityType        string
	PortfolioID         string
	StressTestResult    string
	CapitalAdequacyFlag string
	CreatedAt           string
	UpdatedAt           string
	DeletedAt           string
	LastPaymentAmount   string
	LastPaymentDate     string
	Status              string
}{
	ID:                  "id",
	CustomerID:          "customer_id",
	ProductID:           "product_id",
	LoanAmount:          "loan_amount",
	BalanceOutstanding:  "balance_outstanding",
	StartDate:           "start_date",
	EndDate:             "end_date",
	TermYears:           "term_years",
	ArrearsFlag:         "arrears_flag",
	ArrearsAmount:       "arrears_amount",
	ArrearsDays:         "arrears_days",
	ForbearanceFlag:     "forbearance_flag",
	ForbearanceType:     "forbearance_type",
	FraudFlag:           "fraud_flag",
	FraudNotes:          "fraud_notes",
	RedrawFacility:      "redraw_facility",
	CollateralAddress:   "collateral_address",
	CollateralType:      "collateral_type",
	SecurityType:        "security_type",
	PortfolioID:         "portfolio_id",
	StressTestResult:    "stress_test_result",
	CapitalAdequacyFlag: "capital_adequacy_flag",
	CreatedAt:           "created_at",
	UpdatedAt:           "updated_at",
	DeletedAt:           "deleted_at",
	LastPaymentAmount:   "last_payment_amount",
	LastPaymentDate:     "last_payment_date",
	Status:              "status",
}

var AccountTableColumns = struct {
	ID                  string
	CustomerID          string
	ProductID           string
	LoanAmount          string
	BalanceOutstanding  string
	StartDate           string
	EndDate             string
	TermYears           string
	ArrearsFlag         string
	ArrearsAmount       string
	ArrearsDays         string
	ForbearanceFlag     string
	ForbearanceType     string
	FraudFlag           string
	FraudNotes          string
	RedrawFacility      string
	CollateralAddress   string
	CollateralType      string
	SecurityType        string
	PortfolioID         string
	StressTestResult    string
	CapitalAdequacyFlag string
	CreatedAt           string
	UpdatedAt           string
	DeletedAt           string
	LastPaymentAmount   string
	LastPaymentDate     string
	Status              string
}{
	ID:                  "accounts.id",
	CustomerID:          "accounts.customer_id",
	ProductID:           "accounts.product_id",
	LoanAmount:          "accounts.loan_amount",
	BalanceOutstanding:  "accounts.balance_outstanding",
	StartDate:           "accounts.start_date",
	EndDate:             "accounts.end_date",
	TermYears:           "accounts.term_years",
	ArrearsFlag:         "accounts.arrears_flag",
	ArrearsAmount:       "accounts.arrears_amount",
	ArrearsDays:         "accounts.arrears_days",
	ForbearanceFlag:     "accounts.forbearance_flag",
	ForbearanceType:     "accounts.forbearance_type",
	FraudFlag:           "accounts.fraud_flag",
	FraudNotes:          "accounts.fraud_notes",
	RedrawFacility:      "accounts.redraw_facility",
	CollateralAddress:   "accounts.collateral_address",
	CollateralType:      "accounts.collateral_type",
	SecurityType:        "accounts.security_type",
	PortfolioID:         "accounts.portfolio_id",
	StressTestResult:    "accounts.stress_test_result",
	CapitalAdequacyFlag: "accounts.capital_adequacy_flag",
	CreatedAt:           "accounts.created_at",
	UpdatedAt:           "accounts.updated_at",
	DeletedAt:           "accounts.deleted_at",
	LastPaymentAmount:   "accounts.last_payment_amount",
	LastPaymentDate:     "accounts.last_payment_date",
	Status:              "accounts.status",
}

// Generated where

type whereHelpertypes_Decimal struct{ field string }

func (w whereHelpertypes_Decimal) EQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_Decimal) NEQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_Decimal) LT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Decimal) LTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Decimal) GT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Decimal) GTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Bool struct{ field string }

func (w whereHelpernull_Bool) EQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bool) NEQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bool) LT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bool) LTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bool) GT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bool) GTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Bool) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bool) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpertypes_NullDecimal struct{ field string }

func (w whereHelpertypes_NullDecimal) EQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_NullDecimal) NEQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_NullDecimal) LT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_NullDecimal) LTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_NullDecimal) GT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_NullDecimal) GTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_NullDecimal) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_NullDecimal) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

var AccountWhere = struct {
	ID                  whereHelperstring
	CustomerID          whereHelperstring
	ProductID           whereHelperstring
	LoanAmount          whereHelpertypes_Decimal
	BalanceOutstanding  whereHelpertypes_Decimal
	StartDate           whereHelpertime_Time
	EndDate             whereHelpertime_Time
	TermYears           whereHelperint
	ArrearsFlag         whereHelpernull_Bool
	ArrearsAmount       whereHelpertypes_NullDecimal
	ArrearsDays         whereHelpernull_Int
	ForbearanceFlag     whereHelpernull_Bool
	ForbearanceType     whereHelpernull_String
	FraudFlag           whereHelpernull_Bool
	FraudNotes          whereHelpernull_String
	RedrawFacility      whereHelpernull_Bool
	CollateralAddress   whereHelpernull_String
	CollateralType      whereHelpernull_String
	SecurityType        whereHelpernull_String
	PortfolioID         whereHelpernull_String
	StressTestResult    whereHelpernull_String
	CapitalAdequacyFlag whereHelpernull_Bool
	CreatedAt           whereHelpernull_Time
	UpdatedAt           whereHelpernull_Time
	DeletedAt           whereHelpernull_Time
	LastPaymentAmount   whereHelpertypes_NullDecimal
	LastPaymentDate     whereHelpernull_Time
	Status              whereHelperstring
}{
	ID:                  whereHelperstring{field: "\"accounts\".\"id\""},
	CustomerID:          whereHelperstring{field: "\"accounts\".\"customer_id\""},
	ProductID:           whereHelperstring{field: "\"accounts\".\"product_id\""},
	LoanAmount:          whereHelpertypes_Decimal{field: "\"accounts\".\"loan_amount\""},
	BalanceOutstanding:  whereHelpertypes_Decimal{field: "\"accounts\".\"balance_outstanding\""},
	StartDate:           whereHelpertime_Time{field: "\"accounts\".\"start_date\""},
	EndDate:             whereHelpertime_Time{field: "\"accounts\".\"end_date\""},
	TermYears:           whereHelperint{field: "\"accounts\".\"term_years\""},
	ArrearsFlag:         whereHelpernull_Bool{field: "\"accounts\".\"arrears_flag\""},
	ArrearsAmount:       whereHelpertypes_NullDecimal{field: "\"accounts\".\"arrears_amount\""},
	ArrearsDays:         whereHelpernull_Int{field: "\"accounts\".\"arrears_days\""},
	ForbearanceFlag:     whereHelpernull_Bool{field: "\"accounts\".\"forbearance_flag\""},
	ForbearanceType:     whereHelpernull_String{field: "\"accounts\".\"forbearance_type\""},
	FraudFlag:           whereHelpernull_Bool{field: "\"accounts\".\"fraud_flag\""},
	FraudNotes:          whereHelpernull_String{field: "\"accounts\".\"fraud_notes\""},
	RedrawFacility:      whereHelpernull_Bool{field: "\"accounts\".\"redraw_facility\""},
	CollateralAddress:   whereHelpernull_String{field: "\"accounts\".\"collateral_address\""},
	CollateralType:      whereHelpernull_String{field: "\"accounts\".\"collateral_type\""},
	SecurityType:        whereHelpernull_String{field: "\"accounts\".\"security_type\""},
	PortfolioID:         whereHelpernull_String{field: "\"accounts\".\"portfolio_id\""},
	StressTestResult:    whereHelpernull_String{field: "\"accounts\".\"stress_test_result\""},
	CapitalAdequacyFlag: whereHelpernull_Bool{field: "\"accounts\".\"capital_adequacy_flag\""},
	CreatedAt:           whereHelpernull_Time{field: "\"accounts\".\"created_at\""},
	UpdatedAt:           whereHelpernull_Time{field: "\"accounts\".\"updated_at\""},
	DeletedAt:           whereHelpernull_Time{field: "\"accounts\".\"deleted_at\""},
	LastPaymentAmount:   whereHelpertypes_NullDecimal{field: "\"accounts\".\"last_payment_amount\""},
	LastPaymentDate:     whereHelpernull_Time{field: "\"accounts\".\"last_payment_date\""},
	Status:              whereHelperstring{field: "\"accounts\".\"status\""},
}

// AccountRels is where relationship names are stored.
var AccountRels = struct {
	Customer                   string
	Product                    string
	AccountAuditLogs           string
	AccountFlags               string
	AccountLockRules           string
	Collaterals                string
	Duediligencechecklistitems string
	InvestorRestrictions       string
	LateFeeCalculations        string
	Overpayments               string
	PaymentAdjustments         string
	Payments                   string
	ServicingRestrictions      string
}{
	Customer:                   "Customer",
	Product:                    "Product",
	AccountAuditLogs:           "AccountAuditLogs",
	AccountFlags:               "AccountFlags",
	AccountLockRules:           "AccountLockRules",
	Collaterals:                "Collaterals",
	Duediligencechecklistitems: "Duediligencechecklistitems",
	InvestorRestrictions:       "InvestorRestrictions",
	LateFeeCalculations:        "LateFeeCalculations",
	Overpayments:               "Overpayments",
	PaymentAdjustments:         "PaymentAdjustments",
	Payments:                   "Payments",
	ServicingRestrictions:      "ServicingRestrictions",
}

// accountR is where relationships are stored.
type accountR struct {
	Customer                   *Customer                      `boil:"Customer" json:"Customer" toml:"Customer" yaml:"Customer"`
	Product                    *Product                       `boil:"Product" json:"Product" toml:"Product" yaml:"Product"`
	AccountAuditLogs           AccountAuditLogSlice           `boil:"AccountAuditLogs" json:"AccountAuditLogs" toml:"AccountAuditLogs" yaml:"AccountAuditLogs"`
	AccountFlags               AccountFlagSlice               `boil:"AccountFlags" json:"AccountFlags" toml:"AccountFlags" yaml:"AccountFlags"`
	AccountLockRules           AccountLockRuleSlice           `boil:"AccountLockRules" json:"AccountLockRules" toml:"AccountLockRules" yaml:"AccountLockRules"`
	Collaterals                CollateralSlice                `boil:"Collaterals" json:"Collaterals" toml:"Collaterals" yaml:"Collaterals"`
	Duediligencechecklistitems DuediligencechecklistitemSlice `boil:"Duediligencechecklistitems" json:"Duediligencechecklistitems" toml:"Duediligencechecklistitems" yaml:"Duediligencechecklistitems"`
	InvestorRestrictions       InvestorRestrictionSlice       `boil:"InvestorRestrictions" json:"InvestorRestrictions" toml:"InvestorRestrictions" yaml:"InvestorRestrictions"`
	LateFeeCalculations        LateFeeCalculationSlice        `boil:"LateFeeCalculations" json:"LateFeeCalculations" toml:"LateFeeCalculations" yaml:"LateFeeCalculations"`
	Overpayments               OverpaymentSlice               `boil:"Overpayments" json:"Overpayments" toml:"Overpayments" yaml:"Overpayments"`
	PaymentAdjustments         PaymentAdjustmentSlice         `boil:"PaymentAdjustments" json:"PaymentAdjustments" toml:"PaymentAdjustments" yaml:"PaymentAdjustments"`
	Payments                   PaymentSlice                   `boil:"Payments" json:"Payments" toml:"Payments" yaml:"Payments"`
	ServicingRestrictions      ServicingRestrictionSlice      `boil:"ServicingRestrictions" json:"ServicingRestrictions" toml:"ServicingRestrictions" yaml:"ServicingRestrictions"`
}

// NewStruct creates a new relationship struct
func (*accountR) NewStruct() *accountR {
	return &accountR{}
}

func (o *Account) GetCustomer() *Customer {
	if o == nil {
		return nil
	}

	return o.R.GetCustomer()
}

func (r *accountR) GetCustomer() *Customer {
	if r == nil {
		return nil
	}

	return r.Customer
}

func (o *Account) GetProduct() *Product {
	if o == nil {
		return nil
	}

	return o.R.GetProduct()
}

func (r *accountR) GetProduct() *Product {
	if r == nil {
		return nil
	}

	return r.Product
}

func (o *Account) GetAccountAuditLogs() AccountAuditLogSlice {
	if o == nil {
		return nil
	}

	return o.R.GetAccountAuditLogs()
}

func (r *accountR) GetAccountAuditLogs() AccountAuditLogSlice {
	if r == nil {
		return nil
	}

	return r.AccountAuditLogs
}

func (o *Account) GetAccountFlags() AccountFlagSlice {
	if o == nil {
		return nil
	}

	return o.R.GetAccountFlags()
}

func (r *accountR) GetAccountFlags() AccountFlagSlice {
	if r == nil {
		return nil
	}

	return r.AccountFlags
}

func (o *Account) GetAccountLockRules() AccountLockRuleSlice {
	if o == nil {
		return nil
	}

	return o.R.GetAccountLockRules()
}

func (r *accountR) GetAccountLockRules() AccountLockRuleSlice {
	if r == nil {
		return nil
	}

	return r.AccountLockRules
}

func (o *Account) GetCollaterals() CollateralSlice {
	if o == nil {
		return nil
	}

	return o.R.GetCollaterals()
}

func (r *accountR) GetCollaterals() CollateralSlice {
	if r == nil {
		return nil
	}

	return r.Collaterals
}

func (o *Account) GetDuediligencechecklistitems() DuediligencechecklistitemSlice {
	if o == nil {
		return nil
	}

	return o.R.GetDuediligencechecklistitems()
}

func (r *accountR) GetDuediligencechecklistitems() DuediligencechecklistitemSlice {
	if r == nil {
		return nil
	}

	return r.Duediligencechecklistitems
}

func (o *Account) GetInvestorRestrictions() InvestorRestrictionSlice {
	if o == nil {
		return nil
	}

	return o.R.GetInvestorRestrictions()
}

func (r *accountR) GetInvestorRestrictions() InvestorRestrictionSlice {
	if r == nil {
		return nil
	}

	return r.InvestorRestrictions
}

func (o *Account) GetLateFeeCalculations() LateFeeCalculationSlice {
	if o == nil {
		return nil
	}

	return o.R.GetLateFeeCalculations()
}

func (r *accountR) GetLateFeeCalculations() LateFeeCalculationSlice {
	if r == nil {
		return nil
	}

	return r.LateFeeCalculations
}

func (o *Account) GetOverpayments() OverpaymentSlice {
	if o == nil {
		return nil
	}

	return o.R.GetOverpayments()
}

func (r *accountR) GetOverpayments() OverpaymentSlice {
	if r == nil {
		return nil
	}

	return r.Overpayments
}

func (o *Account) GetPaymentAdjustments() PaymentAdjustmentSlice {
	if o == nil {
		return nil
	}

	return o.R.GetPaymentAdjustments()
}

func (r *accountR) GetPaymentAdjustments() PaymentAdjustmentSlice {
	if r == nil {
		return nil
	}

	return r.PaymentAdjustments
}

func (o *Account) GetPayments() PaymentSlice {
	if o == nil {
		return nil
	}

	return o.R.GetPayments()
}

func (r *accountR) GetPayments() PaymentSlice {
	if r == nil {
		return nil
	}

	return r.Payments
}

func (o *Account) GetServicingRestrictions() ServicingRestrictionSlice {
	if o == nil {
		return nil
	}

	return o.R.GetServicingRestrictions()
}

func (r *accountR) GetServicingRestrictions() ServicingRestrictionSlice {
	if r == nil {
		return nil
	}

	return r.ServicingRestrictions
}

// accountL is where Load methods for each relationship are stored.
type accountL struct{}

var (
	accountAllColumns            = []string{"id", "customer_id", "product_id", "loan_amount", "balance_outstanding", "start_date", "end_date", "term_years", "arrears_flag", "arrears_amount", "arrears_days", "forbearance_flag", "forbearance_type", "fraud_flag", "fraud_notes", "redraw_facility", "collateral_address", "collateral_type", "security_type", "portfolio_id", "stress_test_result", "capital_adequacy_flag", "created_at", "updated_at", "deleted_at", "last_payment_amount", "last_payment_date", "status"}
	accountColumnsWithoutDefault = []string{"id", "customer_id", "product_id", "loan_amount", "balance_outstanding", "start_date", "end_date", "term_years"}
	accountColumnsWithDefault    = []string{"arrears_flag", "arrears_amount", "arrears_days", "forbearance_flag", "forbearance_type", "fraud_flag", "fraud_notes", "redraw_facility", "collateral_address", "collateral_type", "security_type", "portfolio_id", "stress_test_result", "capital_adequacy_flag", "created_at", "updated_at", "deleted_at", "last_payment_amount", "last_payment_date", "status"}
	accountPrimaryKeyColumns     = []string{"id"}
	accountGeneratedColumns      = []string{}
)

type (
	// AccountSlice is an alias for a slice of pointers to Account.
	// This should almost always be used instead of []Account.
	AccountSlice []*Account
	// AccountHook is the signature for custom Account hook methods
	AccountHook func(context.Context, boil.ContextExecutor, *Account) error

	accountQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	accountType                 = reflect.TypeOf(&Account{})
	accountMapping              = queries.MakeStructMapping(accountType)
	accountPrimaryKeyMapping, _ = queries.BindMapping(accountType, accountMapping, accountPrimaryKeyColumns)
	accountInsertCacheMut       sync.RWMutex
	accountInsertCache          = make(map[string]insertCache)
	accountUpdateCacheMut       sync.RWMutex
	accountUpdateCache          = make(map[string]updateCache)
	accountUpsertCacheMut       sync.RWMutex
	accountUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var accountAfterSelectMu sync.Mutex
var accountAfterSelectHooks []AccountHook

var accountBeforeInsertMu sync.Mutex
var accountBeforeInsertHooks []AccountHook
var accountAfterInsertMu sync.Mutex
var accountAfterInsertHooks []AccountHook

var accountBeforeUpdateMu sync.Mutex
var accountBeforeUpdateHooks []AccountHook
var accountAfterUpdateMu sync.Mutex
var accountAfterUpdateHooks []AccountHook

var accountBeforeDeleteMu sync.Mutex
var accountBeforeDeleteHooks []AccountHook
var accountAfterDeleteMu sync.Mutex
var accountAfterDeleteHooks []AccountHook

var accountBeforeUpsertMu sync.Mutex
var accountBeforeUpsertHooks []AccountHook
var accountAfterUpsertMu sync.Mutex
var accountAfterUpsertHooks []AccountHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Account) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Account) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Account) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Account) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Account) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Account) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Account) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Account) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Account) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddAccountHook registers your hook function for all future operations.
func AddAccountHook(hookPoint boil.HookPoint, accountHook AccountHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		accountAfterSelectMu.Lock()
		accountAfterSelectHooks = append(accountAfterSelectHooks, accountHook)
		accountAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		accountBeforeInsertMu.Lock()
		accountBeforeInsertHooks = append(accountBeforeInsertHooks, accountHook)
		accountBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		accountAfterInsertMu.Lock()
		accountAfterInsertHooks = append(accountAfterInsertHooks, accountHook)
		accountAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		accountBeforeUpdateMu.Lock()
		accountBeforeUpdateHooks = append(accountBeforeUpdateHooks, accountHook)
		accountBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		accountAfterUpdateMu.Lock()
		accountAfterUpdateHooks = append(accountAfterUpdateHooks, accountHook)
		accountAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		accountBeforeDeleteMu.Lock()
		accountBeforeDeleteHooks = append(accountBeforeDeleteHooks, accountHook)
		accountBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		accountAfterDeleteMu.Lock()
		accountAfterDeleteHooks = append(accountAfterDeleteHooks, accountHook)
		accountAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		accountBeforeUpsertMu.Lock()
		accountBeforeUpsertHooks = append(accountBeforeUpsertHooks, accountHook)
		accountBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		accountAfterUpsertMu.Lock()
		accountAfterUpsertHooks = append(accountAfterUpsertHooks, accountHook)
		accountAfterUpsertMu.Unlock()
	}
}

// One returns a single account record from the query.
func (q accountQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Account, error) {
	o := &Account{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for accounts")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Account records from the query.
func (q accountQuery) All(ctx context.Context, exec boil.ContextExecutor) (AccountSlice, error) {
	var o []*Account

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to Account slice")
	}

	if len(accountAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Account records in the query.
func (q accountQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count accounts rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q accountQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if accounts exists")
	}

	return count > 0, nil
}

// Customer pointed to by the foreign key.
func (o *Account) Customer(mods ...qm.QueryMod) customerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CustomerID),
	}

	queryMods = append(queryMods, mods...)

	return Customers(queryMods...)
}

// Product pointed to by the foreign key.
func (o *Account) Product(mods ...qm.QueryMod) productQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ProductID),
	}

	queryMods = append(queryMods, mods...)

	return Products(queryMods...)
}

// AccountAuditLogs retrieves all the account_audit_log's AccountAuditLogs with an executor.
func (o *Account) AccountAuditLogs(mods ...qm.QueryMod) accountAuditLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"account_audit_log\".\"account_id\"=?", o.ID),
	)

	return AccountAuditLogs(queryMods...)
}

// AccountFlags retrieves all the account_flag's AccountFlags with an executor.
func (o *Account) AccountFlags(mods ...qm.QueryMod) accountFlagQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"account_flags\".\"account_id\"=?", o.ID),
	)

	return AccountFlags(queryMods...)
}

// AccountLockRules retrieves all the account_lock_rule's AccountLockRules with an executor.
func (o *Account) AccountLockRules(mods ...qm.QueryMod) accountLockRuleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"account_lock_rules\".\"account_id\"=?", o.ID),
	)

	return AccountLockRules(queryMods...)
}

// Collaterals retrieves all the collateral's Collaterals with an executor.
func (o *Account) Collaterals(mods ...qm.QueryMod) collateralQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"collaterals\".\"account_id\"=?", o.ID),
	)

	return Collaterals(queryMods...)
}

// Duediligencechecklistitems retrieves all the duediligencechecklistitem's Duediligencechecklistitems with an executor.
func (o *Account) Duediligencechecklistitems(mods ...qm.QueryMod) duediligencechecklistitemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"duediligencechecklistitems\".\"account_id\"=?", o.ID),
	)

	return Duediligencechecklistitems(queryMods...)
}

// InvestorRestrictions retrieves all the investor_restriction's InvestorRestrictions with an executor.
func (o *Account) InvestorRestrictions(mods ...qm.QueryMod) investorRestrictionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"investor_restrictions\".\"account_id\"=?", o.ID),
	)

	return InvestorRestrictions(queryMods...)
}

// LateFeeCalculations retrieves all the late_fee_calculation's LateFeeCalculations with an executor.
func (o *Account) LateFeeCalculations(mods ...qm.QueryMod) lateFeeCalculationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"late_fee_calculations\".\"account_id\"=?", o.ID),
	)

	return LateFeeCalculations(queryMods...)
}

// Overpayments retrieves all the overpayment's Overpayments with an executor.
func (o *Account) Overpayments(mods ...qm.QueryMod) overpaymentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"overpayments\".\"account_id\"=?", o.ID),
	)

	return Overpayments(queryMods...)
}

// PaymentAdjustments retrieves all the payment_adjustment's PaymentAdjustments with an executor.
func (o *Account) PaymentAdjustments(mods ...qm.QueryMod) paymentAdjustmentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"payment_adjustments\".\"account_id\"=?", o.ID),
	)

	return PaymentAdjustments(queryMods...)
}

// Payments retrieves all the payment's Payments with an executor.
func (o *Account) Payments(mods ...qm.QueryMod) paymentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"payments\".\"account_id\"=?", o.ID),
	)

	return Payments(queryMods...)
}

// ServicingRestrictions retrieves all the servicing_restriction's ServicingRestrictions with an executor.
func (o *Account) ServicingRestrictions(mods ...qm.QueryMod) servicingRestrictionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"servicing_restrictions\".\"account_id\"=?", o.ID),
	)

	return ServicingRestrictions(queryMods...)
}

// LoadCustomer allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (accountL) LoadCustomer(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.CustomerID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			args[obj.CustomerID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`customers`),
		qm.WhereIn(`customers.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Customer")
	}

	var resultSlice []*Customer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Customer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for customers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customers")
	}

	if len(customerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Customer = foreign
		if foreign.R == nil {
			foreign.R = &customerR{}
		}
		foreign.R.Accounts = append(foreign.R.Accounts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CustomerID == foreign.ID {
				local.R.Customer = foreign
				if foreign.R == nil {
					foreign.R = &customerR{}
				}
				foreign.R.Accounts = append(foreign.R.Accounts, local)
				break
			}
		}
	}

	return nil
}

// LoadProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (accountL) LoadProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.ProductID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			args[obj.ProductID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`products`),
		qm.WhereIn(`products.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Product")
	}

	var resultSlice []*Product
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Product")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for products")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for products")
	}

	if len(productAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Product = foreign
		if foreign.R == nil {
			foreign.R = &productR{}
		}
		foreign.R.Accounts = append(foreign.R.Accounts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ProductID == foreign.ID {
				local.R.Product = foreign
				if foreign.R == nil {
					foreign.R = &productR{}
				}
				foreign.R.Accounts = append(foreign.R.Accounts, local)
				break
			}
		}
	}

	return nil
}

// LoadAccountAuditLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountAuditLogs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`account_audit_log`),
		qm.WhereIn(`account_audit_log.account_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load account_audit_log")
	}

	var resultSlice []*AccountAuditLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice account_audit_log")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on account_audit_log")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for account_audit_log")
	}

	if len(accountAuditLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountAuditLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountAuditLogR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.AccountAuditLogs = append(local.R.AccountAuditLogs, foreign)
				if foreign.R == nil {
					foreign.R = &accountAuditLogR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadAccountFlags allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountFlags(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`account_flags`),
		qm.WhereIn(`account_flags.account_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load account_flags")
	}

	var resultSlice []*AccountFlag
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice account_flags")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on account_flags")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for account_flags")
	}

	if len(accountFlagAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountFlags = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountFlagR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.AccountFlags = append(local.R.AccountFlags, foreign)
				if foreign.R == nil {
					foreign.R = &accountFlagR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadAccountLockRules allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountLockRules(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`account_lock_rules`),
		qm.WhereIn(`account_lock_rules.account_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load account_lock_rules")
	}

	var resultSlice []*AccountLockRule
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice account_lock_rules")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on account_lock_rules")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for account_lock_rules")
	}

	if len(accountLockRuleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountLockRules = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountLockRuleR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.AccountLockRules = append(local.R.AccountLockRules, foreign)
				if foreign.R == nil {
					foreign.R = &accountLockRuleR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadCollaterals allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadCollaterals(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`collaterals`),
		qm.WhereIn(`collaterals.account_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load collaterals")
	}

	var resultSlice []*Collateral
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice collaterals")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on collaterals")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for collaterals")
	}

	if len(collateralAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Collaterals = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &collateralR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Collaterals = append(local.R.Collaterals, foreign)
				if foreign.R == nil {
					foreign.R = &collateralR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadDuediligencechecklistitems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadDuediligencechecklistitems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`duediligencechecklistitems`),
		qm.WhereIn(`duediligencechecklistitems.account_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load duediligencechecklistitems")
	}

	var resultSlice []*Duediligencechecklistitem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice duediligencechecklistitems")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on duediligencechecklistitems")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for duediligencechecklistitems")
	}

	if len(duediligencechecklistitemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Duediligencechecklistitems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &duediligencechecklistitemR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Duediligencechecklistitems = append(local.R.Duediligencechecklistitems, foreign)
				if foreign.R == nil {
					foreign.R = &duediligencechecklistitemR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadInvestorRestrictions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadInvestorRestrictions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`investor_restrictions`),
		qm.WhereIn(`investor_restrictions.account_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load investor_restrictions")
	}

	var resultSlice []*InvestorRestriction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice investor_restrictions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on investor_restrictions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for investor_restrictions")
	}

	if len(investorRestrictionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.InvestorRestrictions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &investorRestrictionR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.InvestorRestrictions = append(local.R.InvestorRestrictions, foreign)
				if foreign.R == nil {
					foreign.R = &investorRestrictionR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadLateFeeCalculations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadLateFeeCalculations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`late_fee_calculations`),
		qm.WhereIn(`late_fee_calculations.account_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load late_fee_calculations")
	}

	var resultSlice []*LateFeeCalculation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice late_fee_calculations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on late_fee_calculations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for late_fee_calculations")
	}

	if len(lateFeeCalculationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LateFeeCalculations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &lateFeeCalculationR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.LateFeeCalculations = append(local.R.LateFeeCalculations, foreign)
				if foreign.R == nil {
					foreign.R = &lateFeeCalculationR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadOverpayments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadOverpayments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`overpayments`),
		qm.WhereIn(`overpayments.account_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load overpayments")
	}

	var resultSlice []*Overpayment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice overpayments")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on overpayments")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for overpayments")
	}

	if len(overpaymentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Overpayments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &overpaymentR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Overpayments = append(local.R.Overpayments, foreign)
				if foreign.R == nil {
					foreign.R = &overpaymentR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentAdjustments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadPaymentAdjustments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`payment_adjustments`),
		qm.WhereIn(`payment_adjustments.account_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load payment_adjustments")
	}

	var resultSlice []*PaymentAdjustment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice payment_adjustments")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on payment_adjustments")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for payment_adjustments")
	}

	if len(paymentAdjustmentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentAdjustments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentAdjustmentR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.PaymentAdjustments = append(local.R.PaymentAdjustments, foreign)
				if foreign.R == nil {
					foreign.R = &paymentAdjustmentR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadPayments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadPayments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`payments`),
		qm.WhereIn(`payments.account_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load payments")
	}

	var resultSlice []*Payment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice payments")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on payments")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for payments")
	}

	if len(paymentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Payments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Payments = append(local.R.Payments, foreign)
				if foreign.R == nil {
					foreign.R = &paymentR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadServicingRestrictions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadServicingRestrictions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		var ok bool
		object, ok = maybeAccount.(*Account)
		if !ok {
			object = new(Account)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAccount))
			}
		}
	} else {
		s, ok := maybeAccount.(*[]*Account)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAccount)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAccount))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`servicing_restrictions`),
		qm.WhereIn(`servicing_restrictions.account_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load servicing_restrictions")
	}

	var resultSlice []*ServicingRestriction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice servicing_restrictions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on servicing_restrictions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for servicing_restrictions")
	}

	if len(servicingRestrictionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ServicingRestrictions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &servicingRestrictionR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.AccountID) {
				local.R.ServicingRestrictions = append(local.R.ServicingRestrictions, foreign)
				if foreign.R == nil {
					foreign.R = &servicingRestrictionR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// SetCustomer of the account to the related item.
// Sets o.R.Customer to related.
// Adds o to related.R.Accounts.
func (o *Account) SetCustomer(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Customer) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"accounts\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"customer_id"}),
		strmangle.WhereClause("\"", "\"", 2, accountPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CustomerID = related.ID
	if o.R == nil {
		o.R = &accountR{
			Customer: related,
		}
	} else {
		o.R.Customer = related
	}

	if related.R == nil {
		related.R = &customerR{
			Accounts: AccountSlice{o},
		}
	} else {
		related.R.Accounts = append(related.R.Accounts, o)
	}

	return nil
}

// SetProduct of the account to the related item.
// Sets o.R.Product to related.
// Adds o to related.R.Accounts.
func (o *Account) SetProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Product) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"accounts\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"product_id"}),
		strmangle.WhereClause("\"", "\"", 2, accountPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ProductID = related.ID
	if o.R == nil {
		o.R = &accountR{
			Product: related,
		}
	} else {
		o.R.Product = related
	}

	if related.R == nil {
		related.R = &productR{
			Accounts: AccountSlice{o},
		}
	} else {
		related.R.Accounts = append(related.R.Accounts, o)
	}

	return nil
}

// AddAccountAuditLogs adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.AccountAuditLogs.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountAuditLogs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountAuditLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"account_audit_log\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, accountAuditLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountAuditLogs: related,
		}
	} else {
		o.R.AccountAuditLogs = append(o.R.AccountAuditLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountAuditLogR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddAccountFlags adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.AccountFlags.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountFlags(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountFlag) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"account_flags\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, accountFlagPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountFlags: related,
		}
	} else {
		o.R.AccountFlags = append(o.R.AccountFlags, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountFlagR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddAccountLockRules adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.AccountLockRules.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountLockRules(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountLockRule) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"account_lock_rules\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, accountLockRulePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountLockRules: related,
		}
	} else {
		o.R.AccountLockRules = append(o.R.AccountLockRules, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountLockRuleR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddCollaterals adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Collaterals.
// Sets related.R.Account appropriately.
func (o *Account) AddCollaterals(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Collateral) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"collaterals\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, collateralPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Collaterals: related,
		}
	} else {
		o.R.Collaterals = append(o.R.Collaterals, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &collateralR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddDuediligencechecklistitems adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Duediligencechecklistitems.
// Sets related.R.Account appropriately.
func (o *Account) AddDuediligencechecklistitems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Duediligencechecklistitem) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"duediligencechecklistitems\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, duediligencechecklistitemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Duediligencechecklistitems: related,
		}
	} else {
		o.R.Duediligencechecklistitems = append(o.R.Duediligencechecklistitems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &duediligencechecklistitemR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddInvestorRestrictions adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.InvestorRestrictions.
// Sets related.R.Account appropriately.
func (o *Account) AddInvestorRestrictions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*InvestorRestriction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"investor_restrictions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, investorRestrictionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			InvestorRestrictions: related,
		}
	} else {
		o.R.InvestorRestrictions = append(o.R.InvestorRestrictions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &investorRestrictionR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddLateFeeCalculations adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.LateFeeCalculations.
// Sets related.R.Account appropriately.
func (o *Account) AddLateFeeCalculations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LateFeeCalculation) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"late_fee_calculations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, lateFeeCalculationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			LateFeeCalculations: related,
		}
	} else {
		o.R.LateFeeCalculations = append(o.R.LateFeeCalculations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &lateFeeCalculationR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddOverpayments adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Overpayments.
// Sets related.R.Account appropriately.
func (o *Account) AddOverpayments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Overpayment) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"overpayments\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, overpaymentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Overpayments: related,
		}
	} else {
		o.R.Overpayments = append(o.R.Overpayments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &overpaymentR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddPaymentAdjustments adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.PaymentAdjustments.
// Sets related.R.Account appropriately.
func (o *Account) AddPaymentAdjustments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentAdjustment) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"payment_adjustments\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, paymentAdjustmentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			PaymentAdjustments: related,
		}
	} else {
		o.R.PaymentAdjustments = append(o.R.PaymentAdjustments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentAdjustmentR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddPayments adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Payments.
// Sets related.R.Account appropriately.
func (o *Account) AddPayments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Payment) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"payments\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, paymentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Payments: related,
		}
	} else {
		o.R.Payments = append(o.R.Payments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddServicingRestrictions adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.ServicingRestrictions.
// Sets related.R.Account appropriately.
func (o *Account) AddServicingRestrictions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServicingRestriction) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AccountID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"servicing_restrictions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, servicingRestrictionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AccountID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &accountR{
			ServicingRestrictions: related,
		}
	} else {
		o.R.ServicingRestrictions = append(o.R.ServicingRestrictions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &servicingRestrictionR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// SetServicingRestrictions removes all previously related items of the
// account replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Account's ServicingRestrictions accordingly.
// Replaces o.R.ServicingRestrictions with related.
// Sets related.R.Account's ServicingRestrictions accordingly.
func (o *Account) SetServicingRestrictions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServicingRestriction) error {
	query := "update \"servicing_restrictions\" set \"account_id\" = null where \"account_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ServicingRestrictions {
			queries.SetScanner(&rel.AccountID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Account = nil
		}
		o.R.ServicingRestrictions = nil
	}

	return o.AddServicingRestrictions(ctx, exec, insert, related...)
}

// RemoveServicingRestrictions relationships from objects passed in.
// Removes related items from R.ServicingRestrictions (uses pointer comparison, removal does not keep order)
// Sets related.R.Account.
func (o *Account) RemoveServicingRestrictions(ctx context.Context, exec boil.ContextExecutor, related ...*ServicingRestriction) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AccountID, nil)
		if rel.R != nil {
			rel.R.Account = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("account_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ServicingRestrictions {
			if rel != ri {
				continue
			}

			ln := len(o.R.ServicingRestrictions)
			if ln > 1 && i < ln-1 {
				o.R.ServicingRestrictions[i] = o.R.ServicingRestrictions[ln-1]
			}
			o.R.ServicingRestrictions = o.R.ServicingRestrictions[:ln-1]
			break
		}
	}

	return nil
}

// Accounts retrieves all the records using an executor.
func Accounts(mods ...qm.QueryMod) accountQuery {
	mods = append(mods, qm.From("\"accounts\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"accounts\".*"})
	}

	return accountQuery{q}
}

// FindAccount retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAccount(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Account, error) {
	accountObj := &Account{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"accounts\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, accountObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from accounts")
	}

	if err = accountObj.doAfterSelectHooks(ctx, exec); err != nil {
		return accountObj, err
	}

	return accountObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Account) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no accounts provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(accountColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	accountInsertCacheMut.RLock()
	cache, cached := accountInsertCache[key]
	accountInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			accountAllColumns,
			accountColumnsWithDefault,
			accountColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(accountType, accountMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"accounts\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"accounts\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into accounts")
	}

	if !cached {
		accountInsertCacheMut.Lock()
		accountInsertCache[key] = cache
		accountInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Account.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Account) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	accountUpdateCacheMut.RLock()
	cache, cached := accountUpdateCache[key]
	accountUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			accountAllColumns,
			accountPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update accounts, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"accounts\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, accountPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, append(wl, accountPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update accounts row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for accounts")
	}

	if !cached {
		accountUpdateCacheMut.Lock()
		accountUpdateCache[key] = cache
		accountUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q accountQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for accounts")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for accounts")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AccountSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"accounts\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, accountPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in account slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all account")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Account) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("dbmodels: no accounts provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(accountColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	accountUpsertCacheMut.RLock()
	cache, cached := accountUpsertCache[key]
	accountUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			accountAllColumns,
			accountColumnsWithDefault,
			accountColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			accountAllColumns,
			accountPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert accounts, could not build update column list")
		}

		ret := strmangle.SetComplement(accountAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(accountPrimaryKeyColumns) == 0 {
				return errors.New("dbmodels: unable to upsert accounts, could not build conflict column list")
			}

			conflict = make([]string, len(accountPrimaryKeyColumns))
			copy(conflict, accountPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"accounts\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(accountType, accountMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert accounts")
	}

	if !cached {
		accountUpsertCacheMut.Lock()
		accountUpsertCache[key] = cache
		accountUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Account record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Account) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no Account provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), accountPrimaryKeyMapping)
	sql := "DELETE FROM \"accounts\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from accounts")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for accounts")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q accountQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no accountQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from accounts")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for accounts")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AccountSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(accountBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"accounts\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, accountPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from account slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for accounts")
	}

	if len(accountAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Account) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAccount(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AccountSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AccountSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"accounts\".* FROM \"accounts\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, accountPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in AccountSlice")
	}

	*o = slice

	return nil
}

// AccountExists checks if the Account row exists.
func AccountExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"accounts\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if accounts exists")
	}

	return exists, nil
}

// Exists checks if the Account row exists.
func (o *Account) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return AccountExists(ctx, exec, o.ID)
}
