// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// Quote is an object representing the database table.
type Quote struct {
	ID                string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatedAt         time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt         time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	Status            string      `boil:"status" json:"status" toml:"status" yaml:"status"`
	DepartsAt         time.Time   `boil:"departs_at" json:"departs_at" toml:"departs_at" yaml:"departs_at"`
	ArrivesAt         time.Time   `boil:"arrives_at" json:"arrives_at" toml:"arrives_at" yaml:"arrives_at"`
	ExtraInformation  string      `boil:"extra_information" json:"extra_information" toml:"extra_information" yaml:"extra_information"`
	Price             int64       `boil:"price" json:"price" toml:"price" yaml:"price"`
	AircraftID        null.String `boil:"aircraft_id" json:"aircraft_id,omitempty" toml:"aircraft_id" yaml:"aircraft_id,omitempty"`
	CurrencyCode      string      `boil:"currency_code" json:"currency_code" toml:"currency_code" yaml:"currency_code"`
	QuoteResponseID   null.String `boil:"quote_response_id" json:"quote_response_id,omitempty" toml:"quote_response_id" yaml:"quote_response_id,omitempty"`
	TeamID            string      `boil:"team_id" json:"team_id" toml:"team_id" yaml:"team_id"`
	FromAirportID     string      `boil:"from_airport_id" json:"from_airport_id" toml:"from_airport_id" yaml:"from_airport_id"`
	ToAirportID       string      `boil:"to_airport_id" json:"to_airport_id" toml:"to_airport_id" yaml:"to_airport_id"`
	UserID            int         `boil:"user_id" json:"user_id" toml:"user_id" yaml:"user_id"`
	LegID             null.String `boil:"leg_id" json:"leg_id,omitempty" toml:"leg_id" yaml:"leg_id,omitempty"`
	DepartsAtTimezone string      `boil:"departs_at_timezone" json:"departs_at_timezone" toml:"departs_at_timezone" yaml:"departs_at_timezone"`
	ArrivesAtTimezone string      `boil:"arrives_at_timezone" json:"arrives_at_timezone" toml:"arrives_at_timezone" yaml:"arrives_at_timezone"`
	WorkflowID        string      `boil:"workflow_id" json:"workflow_id" toml:"workflow_id" yaml:"workflow_id"`
	RunID             string      `boil:"run_id" json:"run_id" toml:"run_id" yaml:"run_id"`

	R *quoteR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L quoteL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var QuoteColumns = struct {
	ID                string
	CreatedAt         string
	UpdatedAt         string
	Status            string
	DepartsAt         string
	ArrivesAt         string
	ExtraInformation  string
	Price             string
	AircraftID        string
	CurrencyCode      string
	QuoteResponseID   string
	TeamID            string
	FromAirportID     string
	ToAirportID       string
	UserID            string
	LegID             string
	DepartsAtTimezone string
	ArrivesAtTimezone string
	WorkflowID        string
	RunID             string
}{
	ID:                "id",
	CreatedAt:         "created_at",
	UpdatedAt:         "updated_at",
	Status:            "status",
	DepartsAt:         "departs_at",
	ArrivesAt:         "arrives_at",
	ExtraInformation:  "extra_information",
	Price:             "price",
	AircraftID:        "aircraft_id",
	CurrencyCode:      "currency_code",
	QuoteResponseID:   "quote_response_id",
	TeamID:            "team_id",
	FromAirportID:     "from_airport_id",
	ToAirportID:       "to_airport_id",
	UserID:            "user_id",
	LegID:             "leg_id",
	DepartsAtTimezone: "departs_at_timezone",
	ArrivesAtTimezone: "arrives_at_timezone",
	WorkflowID:        "workflow_id",
	RunID:             "run_id",
}

var QuoteTableColumns = struct {
	ID                string
	CreatedAt         string
	UpdatedAt         string
	Status            string
	DepartsAt         string
	ArrivesAt         string
	ExtraInformation  string
	Price             string
	AircraftID        string
	CurrencyCode      string
	QuoteResponseID   string
	TeamID            string
	FromAirportID     string
	ToAirportID       string
	UserID            string
	LegID             string
	DepartsAtTimezone string
	ArrivesAtTimezone string
	WorkflowID        string
	RunID             string
}{
	ID:                "quote.id",
	CreatedAt:         "quote.created_at",
	UpdatedAt:         "quote.updated_at",
	Status:            "quote.status",
	DepartsAt:         "quote.departs_at",
	ArrivesAt:         "quote.arrives_at",
	ExtraInformation:  "quote.extra_information",
	Price:             "quote.price",
	AircraftID:        "quote.aircraft_id",
	CurrencyCode:      "quote.currency_code",
	QuoteResponseID:   "quote.quote_response_id",
	TeamID:            "quote.team_id",
	FromAirportID:     "quote.from_airport_id",
	ToAirportID:       "quote.to_airport_id",
	UserID:            "quote.user_id",
	LegID:             "quote.leg_id",
	DepartsAtTimezone: "quote.departs_at_timezone",
	ArrivesAtTimezone: "quote.arrives_at_timezone",
	WorkflowID:        "quote.workflow_id",
	RunID:             "quote.run_id",
}

// Generated where

var QuoteWhere = struct {
	ID                whereHelperstring
	CreatedAt         whereHelpertime_Time
	UpdatedAt         whereHelpertime_Time
	Status            whereHelperstring
	DepartsAt         whereHelpertime_Time
	ArrivesAt         whereHelpertime_Time
	ExtraInformation  whereHelperstring
	Price             whereHelperint64
	AircraftID        whereHelpernull_String
	CurrencyCode      whereHelperstring
	QuoteResponseID   whereHelpernull_String
	TeamID            whereHelperstring
	FromAirportID     whereHelperstring
	ToAirportID       whereHelperstring
	UserID            whereHelperint
	LegID             whereHelpernull_String
	DepartsAtTimezone whereHelperstring
	ArrivesAtTimezone whereHelperstring
	WorkflowID        whereHelperstring
	RunID             whereHelperstring
}{
	ID:                whereHelperstring{field: "\"quote\".\"id\""},
	CreatedAt:         whereHelpertime_Time{field: "\"quote\".\"created_at\""},
	UpdatedAt:         whereHelpertime_Time{field: "\"quote\".\"updated_at\""},
	Status:            whereHelperstring{field: "\"quote\".\"status\""},
	DepartsAt:         whereHelpertime_Time{field: "\"quote\".\"departs_at\""},
	ArrivesAt:         whereHelpertime_Time{field: "\"quote\".\"arrives_at\""},
	ExtraInformation:  whereHelperstring{field: "\"quote\".\"extra_information\""},
	Price:             whereHelperint64{field: "\"quote\".\"price\""},
	AircraftID:        whereHelpernull_String{field: "\"quote\".\"aircraft_id\""},
	CurrencyCode:      whereHelperstring{field: "\"quote\".\"currency_code\""},
	QuoteResponseID:   whereHelpernull_String{field: "\"quote\".\"quote_response_id\""},
	TeamID:            whereHelperstring{field: "\"quote\".\"team_id\""},
	FromAirportID:     whereHelperstring{field: "\"quote\".\"from_airport_id\""},
	ToAirportID:       whereHelperstring{field: "\"quote\".\"to_airport_id\""},
	UserID:            whereHelperint{field: "\"quote\".\"user_id\""},
	LegID:             whereHelpernull_String{field: "\"quote\".\"leg_id\""},
	DepartsAtTimezone: whereHelperstring{field: "\"quote\".\"departs_at_timezone\""},
	ArrivesAtTimezone: whereHelperstring{field: "\"quote\".\"arrives_at_timezone\""},
	WorkflowID:        whereHelperstring{field: "\"quote\".\"workflow_id\""},
	RunID:             whereHelperstring{field: "\"quote\".\"run_id\""},
}

// QuoteRels is where relationship names are stored.
var QuoteRels = struct {
	CurrencyCodeCurrency string
	Aircraft             string
	Team                 string
	User                 string
	FromAirport          string
	ToAirport            string
	QuoteResponse        string
	Leg                  string
}{
	CurrencyCodeCurrency: "CurrencyCodeCurrency",
	Aircraft:             "Aircraft",
	Team:                 "Team",
	User:                 "User",
	FromAirport:          "FromAirport",
	ToAirport:            "ToAirport",
	QuoteResponse:        "QuoteResponse",
	Leg:                  "Leg",
}

// quoteR is where relationships are stored.
type quoteR struct {
	CurrencyCodeCurrency *Currency      `boil:"CurrencyCodeCurrency" json:"CurrencyCodeCurrency" toml:"CurrencyCodeCurrency" yaml:"CurrencyCodeCurrency"`
	Aircraft             *Aircraft      `boil:"Aircraft" json:"Aircraft" toml:"Aircraft" yaml:"Aircraft"`
	Team                 *Team          `boil:"Team" json:"Team" toml:"Team" yaml:"Team"`
	User                 *User          `boil:"User" json:"User" toml:"User" yaml:"User"`
	FromAirport          *Airport       `boil:"FromAirport" json:"FromAirport" toml:"FromAirport" yaml:"FromAirport"`
	ToAirport            *Airport       `boil:"ToAirport" json:"ToAirport" toml:"ToAirport" yaml:"ToAirport"`
	QuoteResponse        *QuoteResponse `boil:"QuoteResponse" json:"QuoteResponse" toml:"QuoteResponse" yaml:"QuoteResponse"`
	Leg                  *Leg           `boil:"Leg" json:"Leg" toml:"Leg" yaml:"Leg"`
}

// NewStruct creates a new relationship struct
func (*quoteR) NewStruct() *quoteR {
	return &quoteR{}
}

func (o *Quote) GetCurrencyCodeCurrency() *Currency {
	if o == nil {
		return nil
	}

	return o.R.GetCurrencyCodeCurrency()
}

func (r *quoteR) GetCurrencyCodeCurrency() *Currency {
	if r == nil {
		return nil
	}

	return r.CurrencyCodeCurrency
}

func (o *Quote) GetAircraft() *Aircraft {
	if o == nil {
		return nil
	}

	return o.R.GetAircraft()
}

func (r *quoteR) GetAircraft() *Aircraft {
	if r == nil {
		return nil
	}

	return r.Aircraft
}

func (o *Quote) GetTeam() *Team {
	if o == nil {
		return nil
	}

	return o.R.GetTeam()
}

func (r *quoteR) GetTeam() *Team {
	if r == nil {
		return nil
	}

	return r.Team
}

func (o *Quote) GetUser() *User {
	if o == nil {
		return nil
	}

	return o.R.GetUser()
}

func (r *quoteR) GetUser() *User {
	if r == nil {
		return nil
	}

	return r.User
}

func (o *Quote) GetFromAirport() *Airport {
	if o == nil {
		return nil
	}

	return o.R.GetFromAirport()
}

func (r *quoteR) GetFromAirport() *Airport {
	if r == nil {
		return nil
	}

	return r.FromAirport
}

func (o *Quote) GetToAirport() *Airport {
	if o == nil {
		return nil
	}

	return o.R.GetToAirport()
}

func (r *quoteR) GetToAirport() *Airport {
	if r == nil {
		return nil
	}

	return r.ToAirport
}

func (o *Quote) GetQuoteResponse() *QuoteResponse {
	if o == nil {
		return nil
	}

	return o.R.GetQuoteResponse()
}

func (r *quoteR) GetQuoteResponse() *QuoteResponse {
	if r == nil {
		return nil
	}

	return r.QuoteResponse
}

func (o *Quote) GetLeg() *Leg {
	if o == nil {
		return nil
	}

	return o.R.GetLeg()
}

func (r *quoteR) GetLeg() *Leg {
	if r == nil {
		return nil
	}

	return r.Leg
}

// quoteL is where Load methods for each relationship are stored.
type quoteL struct{}

var (
	quoteAllColumns            = []string{"id", "created_at", "updated_at", "status", "departs_at", "arrives_at", "extra_information", "price", "aircraft_id", "currency_code", "quote_response_id", "team_id", "from_airport_id", "to_airport_id", "user_id", "leg_id", "departs_at_timezone", "arrives_at_timezone", "workflow_id", "run_id"}
	quoteColumnsWithoutDefault = []string{"id", "updated_at", "departs_at", "arrives_at", "extra_information", "price", "currency_code", "team_id", "from_airport_id", "to_airport_id", "user_id"}
	quoteColumnsWithDefault    = []string{"created_at", "status", "aircraft_id", "quote_response_id", "leg_id", "departs_at_timezone", "arrives_at_timezone", "workflow_id", "run_id"}
	quotePrimaryKeyColumns     = []string{"id"}
	quoteGeneratedColumns      = []string{}
)

type (
	// QuoteSlice is an alias for a slice of pointers to Quote.
	// This should almost always be used instead of []Quote.
	QuoteSlice []*Quote
	// QuoteHook is the signature for custom Quote hook methods
	QuoteHook func(context.Context, boil.ContextExecutor, *Quote) error

	quoteQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	quoteType                 = reflect.TypeOf(&Quote{})
	quoteMapping              = queries.MakeStructMapping(quoteType)
	quotePrimaryKeyMapping, _ = queries.BindMapping(quoteType, quoteMapping, quotePrimaryKeyColumns)
	quoteInsertCacheMut       sync.RWMutex
	quoteInsertCache          = make(map[string]insertCache)
	quoteUpdateCacheMut       sync.RWMutex
	quoteUpdateCache          = make(map[string]updateCache)
	quoteUpsertCacheMut       sync.RWMutex
	quoteUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var quoteAfterSelectMu sync.Mutex
var quoteAfterSelectHooks []QuoteHook

var quoteBeforeInsertMu sync.Mutex
var quoteBeforeInsertHooks []QuoteHook
var quoteAfterInsertMu sync.Mutex
var quoteAfterInsertHooks []QuoteHook

var quoteBeforeUpdateMu sync.Mutex
var quoteBeforeUpdateHooks []QuoteHook
var quoteAfterUpdateMu sync.Mutex
var quoteAfterUpdateHooks []QuoteHook

var quoteBeforeDeleteMu sync.Mutex
var quoteBeforeDeleteHooks []QuoteHook
var quoteAfterDeleteMu sync.Mutex
var quoteAfterDeleteHooks []QuoteHook

var quoteBeforeUpsertMu sync.Mutex
var quoteBeforeUpsertHooks []QuoteHook
var quoteAfterUpsertMu sync.Mutex
var quoteAfterUpsertHooks []QuoteHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Quote) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Quote) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Quote) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Quote) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Quote) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Quote) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Quote) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Quote) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Quote) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddQuoteHook registers your hook function for all future operations.
func AddQuoteHook(hookPoint boil.HookPoint, quoteHook QuoteHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		quoteAfterSelectMu.Lock()
		quoteAfterSelectHooks = append(quoteAfterSelectHooks, quoteHook)
		quoteAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		quoteBeforeInsertMu.Lock()
		quoteBeforeInsertHooks = append(quoteBeforeInsertHooks, quoteHook)
		quoteBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		quoteAfterInsertMu.Lock()
		quoteAfterInsertHooks = append(quoteAfterInsertHooks, quoteHook)
		quoteAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		quoteBeforeUpdateMu.Lock()
		quoteBeforeUpdateHooks = append(quoteBeforeUpdateHooks, quoteHook)
		quoteBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		quoteAfterUpdateMu.Lock()
		quoteAfterUpdateHooks = append(quoteAfterUpdateHooks, quoteHook)
		quoteAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		quoteBeforeDeleteMu.Lock()
		quoteBeforeDeleteHooks = append(quoteBeforeDeleteHooks, quoteHook)
		quoteBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		quoteAfterDeleteMu.Lock()
		quoteAfterDeleteHooks = append(quoteAfterDeleteHooks, quoteHook)
		quoteAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		quoteBeforeUpsertMu.Lock()
		quoteBeforeUpsertHooks = append(quoteBeforeUpsertHooks, quoteHook)
		quoteBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		quoteAfterUpsertMu.Lock()
		quoteAfterUpsertHooks = append(quoteAfterUpsertHooks, quoteHook)
		quoteAfterUpsertMu.Unlock()
	}
}

// One returns a single quote record from the query.
func (q quoteQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Quote, error) {
	o := &Quote{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for quote")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Quote records from the query.
func (q quoteQuery) All(ctx context.Context, exec boil.ContextExecutor) (QuoteSlice, error) {
	var o []*Quote

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to Quote slice")
	}

	if len(quoteAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Quote records in the query.
func (q quoteQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count quote rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q quoteQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if quote exists")
	}

	return count > 0, nil
}

// CurrencyCodeCurrency pointed to by the foreign key.
func (o *Quote) CurrencyCodeCurrency(mods ...qm.QueryMod) currencyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"code\" = ?", o.CurrencyCode),
	}

	queryMods = append(queryMods, mods...)

	return Currencies(queryMods...)
}

// Aircraft pointed to by the foreign key.
func (o *Quote) Aircraft(mods ...qm.QueryMod) aircraftQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.AircraftID),
	}

	queryMods = append(queryMods, mods...)

	return Aircrafts(queryMods...)
}

// Team pointed to by the foreign key.
func (o *Quote) Team(mods ...qm.QueryMod) teamQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.TeamID),
	}

	queryMods = append(queryMods, mods...)

	return Teams(queryMods...)
}

// User pointed to by the foreign key.
func (o *Quote) User(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.UserID),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// FromAirport pointed to by the foreign key.
func (o *Quote) FromAirport(mods ...qm.QueryMod) airportQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.FromAirportID),
	}

	queryMods = append(queryMods, mods...)

	return Airports(queryMods...)
}

// ToAirport pointed to by the foreign key.
func (o *Quote) ToAirport(mods ...qm.QueryMod) airportQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ToAirportID),
	}

	queryMods = append(queryMods, mods...)

	return Airports(queryMods...)
}

// QuoteResponse pointed to by the foreign key.
func (o *Quote) QuoteResponse(mods ...qm.QueryMod) quoteResponseQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.QuoteResponseID),
	}

	queryMods = append(queryMods, mods...)

	return QuoteResponses(queryMods...)
}

// Leg pointed to by the foreign key.
func (o *Quote) Leg(mods ...qm.QueryMod) legQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.LegID),
	}

	queryMods = append(queryMods, mods...)

	return Legs(queryMods...)
}

// LoadCurrencyCodeCurrency allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteL) LoadCurrencyCodeCurrency(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuote interface{}, mods queries.Applicator) error {
	var slice []*Quote
	var object *Quote

	if singular {
		var ok bool
		object, ok = maybeQuote.(*Quote)
		if !ok {
			object = new(Quote)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuote))
			}
		}
	} else {
		s, ok := maybeQuote.(*[]*Quote)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuote))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteR{}
		}
		args[object.CurrencyCode] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteR{}
			}

			args[obj.CurrencyCode] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`currency`),
		qm.WhereIn(`currency.code in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Currency")
	}

	var resultSlice []*Currency
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Currency")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for currency")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for currency")
	}

	if len(currencyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CurrencyCodeCurrency = foreign
		if foreign.R == nil {
			foreign.R = &currencyR{}
		}
		foreign.R.CurrencyCodeQuotes = append(foreign.R.CurrencyCodeQuotes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CurrencyCode == foreign.Code {
				local.R.CurrencyCodeCurrency = foreign
				if foreign.R == nil {
					foreign.R = &currencyR{}
				}
				foreign.R.CurrencyCodeQuotes = append(foreign.R.CurrencyCodeQuotes, local)
				break
			}
		}
	}

	return nil
}

// LoadAircraft allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteL) LoadAircraft(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuote interface{}, mods queries.Applicator) error {
	var slice []*Quote
	var object *Quote

	if singular {
		var ok bool
		object, ok = maybeQuote.(*Quote)
		if !ok {
			object = new(Quote)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuote))
			}
		}
	} else {
		s, ok := maybeQuote.(*[]*Quote)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuote))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteR{}
		}
		if !queries.IsNil(object.AircraftID) {
			args[object.AircraftID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteR{}
			}

			if !queries.IsNil(obj.AircraftID) {
				args[obj.AircraftID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`aircraft`),
		qm.WhereIn(`aircraft.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Aircraft")
	}

	var resultSlice []*Aircraft
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Aircraft")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for aircraft")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for aircraft")
	}

	if len(aircraftAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Aircraft = foreign
		if foreign.R == nil {
			foreign.R = &aircraftR{}
		}
		foreign.R.Quotes = append(foreign.R.Quotes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AircraftID, foreign.ID) {
				local.R.Aircraft = foreign
				if foreign.R == nil {
					foreign.R = &aircraftR{}
				}
				foreign.R.Quotes = append(foreign.R.Quotes, local)
				break
			}
		}
	}

	return nil
}

// LoadTeam allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteL) LoadTeam(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuote interface{}, mods queries.Applicator) error {
	var slice []*Quote
	var object *Quote

	if singular {
		var ok bool
		object, ok = maybeQuote.(*Quote)
		if !ok {
			object = new(Quote)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuote))
			}
		}
	} else {
		s, ok := maybeQuote.(*[]*Quote)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuote))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteR{}
		}
		args[object.TeamID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteR{}
			}

			args[obj.TeamID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`team`),
		qm.WhereIn(`team.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Team")
	}

	var resultSlice []*Team
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Team")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for team")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for team")
	}

	if len(teamAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Team = foreign
		if foreign.R == nil {
			foreign.R = &teamR{}
		}
		foreign.R.Quotes = append(foreign.R.Quotes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.TeamID == foreign.ID {
				local.R.Team = foreign
				if foreign.R == nil {
					foreign.R = &teamR{}
				}
				foreign.R.Quotes = append(foreign.R.Quotes, local)
				break
			}
		}
	}

	return nil
}

// LoadUser allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteL) LoadUser(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuote interface{}, mods queries.Applicator) error {
	var slice []*Quote
	var object *Quote

	if singular {
		var ok bool
		object, ok = maybeQuote.(*Quote)
		if !ok {
			object = new(Quote)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuote))
			}
		}
	} else {
		s, ok := maybeQuote.(*[]*Quote)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuote))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteR{}
		}
		args[object.UserID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteR{}
			}

			args[obj.UserID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.User = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.Quotes = append(foreign.R.Quotes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.UserID == foreign.ID {
				local.R.User = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.Quotes = append(foreign.R.Quotes, local)
				break
			}
		}
	}

	return nil
}

// LoadFromAirport allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteL) LoadFromAirport(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuote interface{}, mods queries.Applicator) error {
	var slice []*Quote
	var object *Quote

	if singular {
		var ok bool
		object, ok = maybeQuote.(*Quote)
		if !ok {
			object = new(Quote)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuote))
			}
		}
	} else {
		s, ok := maybeQuote.(*[]*Quote)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuote))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteR{}
		}
		args[object.FromAirportID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteR{}
			}

			args[obj.FromAirportID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`airport`),
		qm.WhereIn(`airport.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Airport")
	}

	var resultSlice []*Airport
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Airport")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for airport")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for airport")
	}

	if len(airportAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.FromAirport = foreign
		if foreign.R == nil {
			foreign.R = &airportR{}
		}
		foreign.R.FromAirportQuotes = append(foreign.R.FromAirportQuotes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FromAirportID == foreign.ID {
				local.R.FromAirport = foreign
				if foreign.R == nil {
					foreign.R = &airportR{}
				}
				foreign.R.FromAirportQuotes = append(foreign.R.FromAirportQuotes, local)
				break
			}
		}
	}

	return nil
}

// LoadToAirport allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteL) LoadToAirport(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuote interface{}, mods queries.Applicator) error {
	var slice []*Quote
	var object *Quote

	if singular {
		var ok bool
		object, ok = maybeQuote.(*Quote)
		if !ok {
			object = new(Quote)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuote))
			}
		}
	} else {
		s, ok := maybeQuote.(*[]*Quote)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuote))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteR{}
		}
		args[object.ToAirportID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteR{}
			}

			args[obj.ToAirportID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`airport`),
		qm.WhereIn(`airport.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Airport")
	}

	var resultSlice []*Airport
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Airport")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for airport")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for airport")
	}

	if len(airportAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ToAirport = foreign
		if foreign.R == nil {
			foreign.R = &airportR{}
		}
		foreign.R.ToAirportQuotes = append(foreign.R.ToAirportQuotes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ToAirportID == foreign.ID {
				local.R.ToAirport = foreign
				if foreign.R == nil {
					foreign.R = &airportR{}
				}
				foreign.R.ToAirportQuotes = append(foreign.R.ToAirportQuotes, local)
				break
			}
		}
	}

	return nil
}

// LoadQuoteResponse allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteL) LoadQuoteResponse(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuote interface{}, mods queries.Applicator) error {
	var slice []*Quote
	var object *Quote

	if singular {
		var ok bool
		object, ok = maybeQuote.(*Quote)
		if !ok {
			object = new(Quote)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuote))
			}
		}
	} else {
		s, ok := maybeQuote.(*[]*Quote)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuote))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteR{}
		}
		if !queries.IsNil(object.QuoteResponseID) {
			args[object.QuoteResponseID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteR{}
			}

			if !queries.IsNil(obj.QuoteResponseID) {
				args[obj.QuoteResponseID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`quote_response`),
		qm.WhereIn(`quote_response.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load QuoteResponse")
	}

	var resultSlice []*QuoteResponse
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice QuoteResponse")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for quote_response")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quote_response")
	}

	if len(quoteResponseAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.QuoteResponse = foreign
		if foreign.R == nil {
			foreign.R = &quoteResponseR{}
		}
		foreign.R.Quote = object
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.QuoteResponseID, foreign.ID) {
				local.R.QuoteResponse = foreign
				if foreign.R == nil {
					foreign.R = &quoteResponseR{}
				}
				foreign.R.Quote = local
				break
			}
		}
	}

	return nil
}

// LoadLeg allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteL) LoadLeg(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuote interface{}, mods queries.Applicator) error {
	var slice []*Quote
	var object *Quote

	if singular {
		var ok bool
		object, ok = maybeQuote.(*Quote)
		if !ok {
			object = new(Quote)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuote))
			}
		}
	} else {
		s, ok := maybeQuote.(*[]*Quote)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuote)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuote))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteR{}
		}
		if !queries.IsNil(object.LegID) {
			args[object.LegID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteR{}
			}

			if !queries.IsNil(obj.LegID) {
				args[obj.LegID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`leg`),
		qm.WhereIn(`leg.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Leg")
	}

	var resultSlice []*Leg
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Leg")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for leg")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for leg")
	}

	if len(legAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Leg = foreign
		if foreign.R == nil {
			foreign.R = &legR{}
		}
		foreign.R.Quotes = append(foreign.R.Quotes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.LegID, foreign.ID) {
				local.R.Leg = foreign
				if foreign.R == nil {
					foreign.R = &legR{}
				}
				foreign.R.Quotes = append(foreign.R.Quotes, local)
				break
			}
		}
	}

	return nil
}

// SetCurrencyCodeCurrency of the quote to the related item.
// Sets o.R.CurrencyCodeCurrency to related.
// Adds o to related.R.CurrencyCodeQuotes.
func (o *Quote) SetCurrencyCodeCurrency(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Currency) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"currency_code"}),
		strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
	)
	values := []interface{}{related.Code, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CurrencyCode = related.Code
	if o.R == nil {
		o.R = &quoteR{
			CurrencyCodeCurrency: related,
		}
	} else {
		o.R.CurrencyCodeCurrency = related
	}

	if related.R == nil {
		related.R = &currencyR{
			CurrencyCodeQuotes: QuoteSlice{o},
		}
	} else {
		related.R.CurrencyCodeQuotes = append(related.R.CurrencyCodeQuotes, o)
	}

	return nil
}

// SetAircraft of the quote to the related item.
// Sets o.R.Aircraft to related.
// Adds o to related.R.Quotes.
func (o *Quote) SetAircraft(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Aircraft) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"aircraft_id"}),
		strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AircraftID, related.ID)
	if o.R == nil {
		o.R = &quoteR{
			Aircraft: related,
		}
	} else {
		o.R.Aircraft = related
	}

	if related.R == nil {
		related.R = &aircraftR{
			Quotes: QuoteSlice{o},
		}
	} else {
		related.R.Quotes = append(related.R.Quotes, o)
	}

	return nil
}

// RemoveAircraft relationship.
// Sets o.R.Aircraft to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Quote) RemoveAircraft(ctx context.Context, exec boil.ContextExecutor, related *Aircraft) error {
	var err error

	queries.SetScanner(&o.AircraftID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("aircraft_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Aircraft = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Quotes {
		if queries.Equal(o.AircraftID, ri.AircraftID) {
			continue
		}

		ln := len(related.R.Quotes)
		if ln > 1 && i < ln-1 {
			related.R.Quotes[i] = related.R.Quotes[ln-1]
		}
		related.R.Quotes = related.R.Quotes[:ln-1]
		break
	}
	return nil
}

// SetTeam of the quote to the related item.
// Sets o.R.Team to related.
// Adds o to related.R.Quotes.
func (o *Quote) SetTeam(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Team) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"team_id"}),
		strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.TeamID = related.ID
	if o.R == nil {
		o.R = &quoteR{
			Team: related,
		}
	} else {
		o.R.Team = related
	}

	if related.R == nil {
		related.R = &teamR{
			Quotes: QuoteSlice{o},
		}
	} else {
		related.R.Quotes = append(related.R.Quotes, o)
	}

	return nil
}

// SetUser of the quote to the related item.
// Sets o.R.User to related.
// Adds o to related.R.Quotes.
func (o *Quote) SetUser(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
		strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.UserID = related.ID
	if o.R == nil {
		o.R = &quoteR{
			User: related,
		}
	} else {
		o.R.User = related
	}

	if related.R == nil {
		related.R = &userR{
			Quotes: QuoteSlice{o},
		}
	} else {
		related.R.Quotes = append(related.R.Quotes, o)
	}

	return nil
}

// SetFromAirport of the quote to the related item.
// Sets o.R.FromAirport to related.
// Adds o to related.R.FromAirportQuotes.
func (o *Quote) SetFromAirport(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Airport) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"from_airport_id"}),
		strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.FromAirportID = related.ID
	if o.R == nil {
		o.R = &quoteR{
			FromAirport: related,
		}
	} else {
		o.R.FromAirport = related
	}

	if related.R == nil {
		related.R = &airportR{
			FromAirportQuotes: QuoteSlice{o},
		}
	} else {
		related.R.FromAirportQuotes = append(related.R.FromAirportQuotes, o)
	}

	return nil
}

// SetToAirport of the quote to the related item.
// Sets o.R.ToAirport to related.
// Adds o to related.R.ToAirportQuotes.
func (o *Quote) SetToAirport(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Airport) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"to_airport_id"}),
		strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ToAirportID = related.ID
	if o.R == nil {
		o.R = &quoteR{
			ToAirport: related,
		}
	} else {
		o.R.ToAirport = related
	}

	if related.R == nil {
		related.R = &airportR{
			ToAirportQuotes: QuoteSlice{o},
		}
	} else {
		related.R.ToAirportQuotes = append(related.R.ToAirportQuotes, o)
	}

	return nil
}

// SetQuoteResponse of the quote to the related item.
// Sets o.R.QuoteResponse to related.
// Adds o to related.R.Quote.
func (o *Quote) SetQuoteResponse(ctx context.Context, exec boil.ContextExecutor, insert bool, related *QuoteResponse) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"quote_response_id"}),
		strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.QuoteResponseID, related.ID)
	if o.R == nil {
		o.R = &quoteR{
			QuoteResponse: related,
		}
	} else {
		o.R.QuoteResponse = related
	}

	if related.R == nil {
		related.R = &quoteResponseR{
			Quote: o,
		}
	} else {
		related.R.Quote = o
	}

	return nil
}

// RemoveQuoteResponse relationship.
// Sets o.R.QuoteResponse to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Quote) RemoveQuoteResponse(ctx context.Context, exec boil.ContextExecutor, related *QuoteResponse) error {
	var err error

	queries.SetScanner(&o.QuoteResponseID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("quote_response_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.QuoteResponse = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	related.R.Quote = nil
	return nil
}

// SetLeg of the quote to the related item.
// Sets o.R.Leg to related.
// Adds o to related.R.Quotes.
func (o *Quote) SetLeg(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Leg) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"leg_id"}),
		strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.LegID, related.ID)
	if o.R == nil {
		o.R = &quoteR{
			Leg: related,
		}
	} else {
		o.R.Leg = related
	}

	if related.R == nil {
		related.R = &legR{
			Quotes: QuoteSlice{o},
		}
	} else {
		related.R.Quotes = append(related.R.Quotes, o)
	}

	return nil
}

// RemoveLeg relationship.
// Sets o.R.Leg to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Quote) RemoveLeg(ctx context.Context, exec boil.ContextExecutor, related *Leg) error {
	var err error

	queries.SetScanner(&o.LegID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("leg_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Leg = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Quotes {
		if queries.Equal(o.LegID, ri.LegID) {
			continue
		}

		ln := len(related.R.Quotes)
		if ln > 1 && i < ln-1 {
			related.R.Quotes[i] = related.R.Quotes[ln-1]
		}
		related.R.Quotes = related.R.Quotes[:ln-1]
		break
	}
	return nil
}

// Quotes retrieves all the records using an executor.
func Quotes(mods ...qm.QueryMod) quoteQuery {
	mods = append(mods, qm.From("\"quote\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"quote\".*"})
	}

	return quoteQuery{q}
}

// FindQuote retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindQuote(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Quote, error) {
	quoteObj := &Quote{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"quote\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, quoteObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from quote")
	}

	if err = quoteObj.doAfterSelectHooks(ctx, exec); err != nil {
		return quoteObj, err
	}

	return quoteObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Quote) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no quote provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(quoteColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	quoteInsertCacheMut.RLock()
	cache, cached := quoteInsertCache[key]
	quoteInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			quoteAllColumns,
			quoteColumnsWithDefault,
			quoteColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(quoteType, quoteMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(quoteType, quoteMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"quote\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"quote\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into quote")
	}

	if !cached {
		quoteInsertCacheMut.Lock()
		quoteInsertCache[key] = cache
		quoteInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Quote.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Quote) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	quoteUpdateCacheMut.RLock()
	cache, cached := quoteUpdateCache[key]
	quoteUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			quoteAllColumns,
			quotePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update quote, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"quote\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, quotePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(quoteType, quoteMapping, append(wl, quotePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update quote row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for quote")
	}

	if !cached {
		quoteUpdateCacheMut.Lock()
		quoteUpdateCache[key] = cache
		quoteUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q quoteQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for quote")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for quote")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o QuoteSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), quotePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"quote\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, quotePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in quote slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all quote")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Quote) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("dbmodels: no quote provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(quoteColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	quoteUpsertCacheMut.RLock()
	cache, cached := quoteUpsertCache[key]
	quoteUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			quoteAllColumns,
			quoteColumnsWithDefault,
			quoteColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			quoteAllColumns,
			quotePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert quote, could not build update column list")
		}

		ret := strmangle.SetComplement(quoteAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(quotePrimaryKeyColumns) == 0 {
				return errors.New("dbmodels: unable to upsert quote, could not build conflict column list")
			}

			conflict = make([]string, len(quotePrimaryKeyColumns))
			copy(conflict, quotePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"quote\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(quoteType, quoteMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(quoteType, quoteMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert quote")
	}

	if !cached {
		quoteUpsertCacheMut.Lock()
		quoteUpsertCache[key] = cache
		quoteUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Quote record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Quote) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no Quote provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), quotePrimaryKeyMapping)
	sql := "DELETE FROM \"quote\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from quote")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for quote")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q quoteQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no quoteQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from quote")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for quote")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o QuoteSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(quoteBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), quotePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"quote\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, quotePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from quote slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for quote")
	}

	if len(quoteAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Quote) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindQuote(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *QuoteSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := QuoteSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), quotePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"quote\".* FROM \"quote\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, quotePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in QuoteSlice")
	}

	*o = slice

	return nil
}

// QuoteExists checks if the Quote row exists.
func QuoteExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"quote\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if quote exists")
	}

	return exists, nil
}

// Exists checks if the Quote row exists.
func (o *Quote) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return QuoteExists(ctx, exec, o.ID)
}
