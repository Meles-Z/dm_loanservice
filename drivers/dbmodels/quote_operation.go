// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// QuoteOperation is an object representing the database table.
type QuoteOperation struct {
	ID               string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	QuoteHeaderID    string      `boil:"quote_header_id" json:"quote_header_id" toml:"quote_header_id" yaml:"quote_header_id"`
	CreatedAt        time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt        time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DepartsAt        time.Time   `boil:"departs_at" json:"departs_at" toml:"departs_at" yaml:"departs_at"`
	FromAirportID    string      `boil:"from_airport_id" json:"from_airport_id" toml:"from_airport_id" yaml:"from_airport_id"`
	ToAirportID      string      `boil:"to_airport_id" json:"to_airport_id" toml:"to_airport_id" yaml:"to_airport_id"`
	TeamID           string      `boil:"team_id" json:"team_id" toml:"team_id" yaml:"team_id"`
	Passenger        int         `boil:"passenger" json:"passenger" toml:"passenger" yaml:"passenger"`
	FlagNotQuoted    bool        `boil:"flag_not_quoted" json:"flag_not_quoted" toml:"flag_not_quoted" yaml:"flag_not_quoted"`
	FlagRejected     bool        `boil:"flag_rejected" json:"flag_rejected" toml:"flag_rejected" yaml:"flag_rejected"`
	ReadyToQuote     bool        `boil:"ready_to_quote" json:"ready_to_quote" toml:"ready_to_quote" yaml:"ready_to_quote"`
	ExtraInformation null.String `boil:"extra_information" json:"extra_information,omitempty" toml:"extra_information" yaml:"extra_information,omitempty"`
	Price            null.Int64  `boil:"price" json:"price,omitempty" toml:"price" yaml:"price,omitempty"`
	CurrencyCode     null.String `boil:"currency_code" json:"currency_code,omitempty" toml:"currency_code" yaml:"currency_code,omitempty"`
	AircraftID       null.String `boil:"aircraft_id" json:"aircraft_id,omitempty" toml:"aircraft_id" yaml:"aircraft_id,omitempty"`
	ArrivesAt        null.Time   `boil:"arrives_at" json:"arrives_at,omitempty" toml:"arrives_at" yaml:"arrives_at,omitempty"`
	UserID           int         `boil:"user_id" json:"user_id" toml:"user_id" yaml:"user_id"`
	QuoteResponseID  null.String `boil:"quote_response_id" json:"quote_response_id,omitempty" toml:"quote_response_id" yaml:"quote_response_id,omitempty"`
	LegID            null.String `boil:"leg_id" json:"leg_id,omitempty" toml:"leg_id" yaml:"leg_id,omitempty"`
	Status           string      `boil:"status" json:"status" toml:"status" yaml:"status"`

	R *quoteOperationR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L quoteOperationL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var QuoteOperationColumns = struct {
	ID               string
	QuoteHeaderID    string
	CreatedAt        string
	UpdatedAt        string
	DepartsAt        string
	FromAirportID    string
	ToAirportID      string
	TeamID           string
	Passenger        string
	FlagNotQuoted    string
	FlagRejected     string
	ReadyToQuote     string
	ExtraInformation string
	Price            string
	CurrencyCode     string
	AircraftID       string
	ArrivesAt        string
	UserID           string
	QuoteResponseID  string
	LegID            string
	Status           string
}{
	ID:               "id",
	QuoteHeaderID:    "quote_header_id",
	CreatedAt:        "created_at",
	UpdatedAt:        "updated_at",
	DepartsAt:        "departs_at",
	FromAirportID:    "from_airport_id",
	ToAirportID:      "to_airport_id",
	TeamID:           "team_id",
	Passenger:        "passenger",
	FlagNotQuoted:    "flag_not_quoted",
	FlagRejected:     "flag_rejected",
	ReadyToQuote:     "ready_to_quote",
	ExtraInformation: "extra_information",
	Price:            "price",
	CurrencyCode:     "currency_code",
	AircraftID:       "aircraft_id",
	ArrivesAt:        "arrives_at",
	UserID:           "user_id",
	QuoteResponseID:  "quote_response_id",
	LegID:            "leg_id",
	Status:           "status",
}

var QuoteOperationTableColumns = struct {
	ID               string
	QuoteHeaderID    string
	CreatedAt        string
	UpdatedAt        string
	DepartsAt        string
	FromAirportID    string
	ToAirportID      string
	TeamID           string
	Passenger        string
	FlagNotQuoted    string
	FlagRejected     string
	ReadyToQuote     string
	ExtraInformation string
	Price            string
	CurrencyCode     string
	AircraftID       string
	ArrivesAt        string
	UserID           string
	QuoteResponseID  string
	LegID            string
	Status           string
}{
	ID:               "quote_operation.id",
	QuoteHeaderID:    "quote_operation.quote_header_id",
	CreatedAt:        "quote_operation.created_at",
	UpdatedAt:        "quote_operation.updated_at",
	DepartsAt:        "quote_operation.departs_at",
	FromAirportID:    "quote_operation.from_airport_id",
	ToAirportID:      "quote_operation.to_airport_id",
	TeamID:           "quote_operation.team_id",
	Passenger:        "quote_operation.passenger",
	FlagNotQuoted:    "quote_operation.flag_not_quoted",
	FlagRejected:     "quote_operation.flag_rejected",
	ReadyToQuote:     "quote_operation.ready_to_quote",
	ExtraInformation: "quote_operation.extra_information",
	Price:            "quote_operation.price",
	CurrencyCode:     "quote_operation.currency_code",
	AircraftID:       "quote_operation.aircraft_id",
	ArrivesAt:        "quote_operation.arrives_at",
	UserID:           "quote_operation.user_id",
	QuoteResponseID:  "quote_operation.quote_response_id",
	LegID:            "quote_operation.leg_id",
	Status:           "quote_operation.status",
}

// Generated where

var QuoteOperationWhere = struct {
	ID               whereHelperstring
	QuoteHeaderID    whereHelperstring
	CreatedAt        whereHelpertime_Time
	UpdatedAt        whereHelpertime_Time
	DepartsAt        whereHelpertime_Time
	FromAirportID    whereHelperstring
	ToAirportID      whereHelperstring
	TeamID           whereHelperstring
	Passenger        whereHelperint
	FlagNotQuoted    whereHelperbool
	FlagRejected     whereHelperbool
	ReadyToQuote     whereHelperbool
	ExtraInformation whereHelpernull_String
	Price            whereHelpernull_Int64
	CurrencyCode     whereHelpernull_String
	AircraftID       whereHelpernull_String
	ArrivesAt        whereHelpernull_Time
	UserID           whereHelperint
	QuoteResponseID  whereHelpernull_String
	LegID            whereHelpernull_String
	Status           whereHelperstring
}{
	ID:               whereHelperstring{field: "\"quote_operation\".\"id\""},
	QuoteHeaderID:    whereHelperstring{field: "\"quote_operation\".\"quote_header_id\""},
	CreatedAt:        whereHelpertime_Time{field: "\"quote_operation\".\"created_at\""},
	UpdatedAt:        whereHelpertime_Time{field: "\"quote_operation\".\"updated_at\""},
	DepartsAt:        whereHelpertime_Time{field: "\"quote_operation\".\"departs_at\""},
	FromAirportID:    whereHelperstring{field: "\"quote_operation\".\"from_airport_id\""},
	ToAirportID:      whereHelperstring{field: "\"quote_operation\".\"to_airport_id\""},
	TeamID:           whereHelperstring{field: "\"quote_operation\".\"team_id\""},
	Passenger:        whereHelperint{field: "\"quote_operation\".\"passenger\""},
	FlagNotQuoted:    whereHelperbool{field: "\"quote_operation\".\"flag_not_quoted\""},
	FlagRejected:     whereHelperbool{field: "\"quote_operation\".\"flag_rejected\""},
	ReadyToQuote:     whereHelperbool{field: "\"quote_operation\".\"ready_to_quote\""},
	ExtraInformation: whereHelpernull_String{field: "\"quote_operation\".\"extra_information\""},
	Price:            whereHelpernull_Int64{field: "\"quote_operation\".\"price\""},
	CurrencyCode:     whereHelpernull_String{field: "\"quote_operation\".\"currency_code\""},
	AircraftID:       whereHelpernull_String{field: "\"quote_operation\".\"aircraft_id\""},
	ArrivesAt:        whereHelpernull_Time{field: "\"quote_operation\".\"arrives_at\""},
	UserID:           whereHelperint{field: "\"quote_operation\".\"user_id\""},
	QuoteResponseID:  whereHelpernull_String{field: "\"quote_operation\".\"quote_response_id\""},
	LegID:            whereHelpernull_String{field: "\"quote_operation\".\"leg_id\""},
	Status:           whereHelperstring{field: "\"quote_operation\".\"status\""},
}

// QuoteOperationRels is where relationship names are stored.
var QuoteOperationRels = struct {
	FromAirport          string
	ToAirport            string
	QuoteHeader          string
	Aircraft             string
	CurrencyCodeCurrency string
	Team                 string
	User                 string
	QuoteResponse        string
	Leg                  string
}{
	FromAirport:          "FromAirport",
	ToAirport:            "ToAirport",
	QuoteHeader:          "QuoteHeader",
	Aircraft:             "Aircraft",
	CurrencyCodeCurrency: "CurrencyCodeCurrency",
	Team:                 "Team",
	User:                 "User",
	QuoteResponse:        "QuoteResponse",
	Leg:                  "Leg",
}

// quoteOperationR is where relationships are stored.
type quoteOperationR struct {
	FromAirport          *Airport       `boil:"FromAirport" json:"FromAirport" toml:"FromAirport" yaml:"FromAirport"`
	ToAirport            *Airport       `boil:"ToAirport" json:"ToAirport" toml:"ToAirport" yaml:"ToAirport"`
	QuoteHeader          *QuoteHeader   `boil:"QuoteHeader" json:"QuoteHeader" toml:"QuoteHeader" yaml:"QuoteHeader"`
	Aircraft             *Aircraft      `boil:"Aircraft" json:"Aircraft" toml:"Aircraft" yaml:"Aircraft"`
	CurrencyCodeCurrency *Currency      `boil:"CurrencyCodeCurrency" json:"CurrencyCodeCurrency" toml:"CurrencyCodeCurrency" yaml:"CurrencyCodeCurrency"`
	Team                 *Team          `boil:"Team" json:"Team" toml:"Team" yaml:"Team"`
	User                 *User          `boil:"User" json:"User" toml:"User" yaml:"User"`
	QuoteResponse        *QuoteResponse `boil:"QuoteResponse" json:"QuoteResponse" toml:"QuoteResponse" yaml:"QuoteResponse"`
	Leg                  *EmptyLeg      `boil:"Leg" json:"Leg" toml:"Leg" yaml:"Leg"`
}

// NewStruct creates a new relationship struct
func (*quoteOperationR) NewStruct() *quoteOperationR {
	return &quoteOperationR{}
}

func (o *QuoteOperation) GetFromAirport() *Airport {
	if o == nil {
		return nil
	}

	return o.R.GetFromAirport()
}

func (r *quoteOperationR) GetFromAirport() *Airport {
	if r == nil {
		return nil
	}

	return r.FromAirport
}

func (o *QuoteOperation) GetToAirport() *Airport {
	if o == nil {
		return nil
	}

	return o.R.GetToAirport()
}

func (r *quoteOperationR) GetToAirport() *Airport {
	if r == nil {
		return nil
	}

	return r.ToAirport
}

func (o *QuoteOperation) GetQuoteHeader() *QuoteHeader {
	if o == nil {
		return nil
	}

	return o.R.GetQuoteHeader()
}

func (r *quoteOperationR) GetQuoteHeader() *QuoteHeader {
	if r == nil {
		return nil
	}

	return r.QuoteHeader
}

func (o *QuoteOperation) GetAircraft() *Aircraft {
	if o == nil {
		return nil
	}

	return o.R.GetAircraft()
}

func (r *quoteOperationR) GetAircraft() *Aircraft {
	if r == nil {
		return nil
	}

	return r.Aircraft
}

func (o *QuoteOperation) GetCurrencyCodeCurrency() *Currency {
	if o == nil {
		return nil
	}

	return o.R.GetCurrencyCodeCurrency()
}

func (r *quoteOperationR) GetCurrencyCodeCurrency() *Currency {
	if r == nil {
		return nil
	}

	return r.CurrencyCodeCurrency
}

func (o *QuoteOperation) GetTeam() *Team {
	if o == nil {
		return nil
	}

	return o.R.GetTeam()
}

func (r *quoteOperationR) GetTeam() *Team {
	if r == nil {
		return nil
	}

	return r.Team
}

func (o *QuoteOperation) GetUser() *User {
	if o == nil {
		return nil
	}

	return o.R.GetUser()
}

func (r *quoteOperationR) GetUser() *User {
	if r == nil {
		return nil
	}

	return r.User
}

func (o *QuoteOperation) GetQuoteResponse() *QuoteResponse {
	if o == nil {
		return nil
	}

	return o.R.GetQuoteResponse()
}

func (r *quoteOperationR) GetQuoteResponse() *QuoteResponse {
	if r == nil {
		return nil
	}

	return r.QuoteResponse
}

func (o *QuoteOperation) GetLeg() *EmptyLeg {
	if o == nil {
		return nil
	}

	return o.R.GetLeg()
}

func (r *quoteOperationR) GetLeg() *EmptyLeg {
	if r == nil {
		return nil
	}

	return r.Leg
}

// quoteOperationL is where Load methods for each relationship are stored.
type quoteOperationL struct{}

var (
	quoteOperationAllColumns            = []string{"id", "quote_header_id", "created_at", "updated_at", "departs_at", "from_airport_id", "to_airport_id", "team_id", "passenger", "flag_not_quoted", "flag_rejected", "ready_to_quote", "extra_information", "price", "currency_code", "aircraft_id", "arrives_at", "user_id", "quote_response_id", "leg_id", "status"}
	quoteOperationColumnsWithoutDefault = []string{"id", "quote_header_id", "updated_at", "departs_at", "from_airport_id", "to_airport_id", "team_id", "user_id"}
	quoteOperationColumnsWithDefault    = []string{"created_at", "passenger", "flag_not_quoted", "flag_rejected", "ready_to_quote", "extra_information", "price", "currency_code", "aircraft_id", "arrives_at", "quote_response_id", "leg_id", "status"}
	quoteOperationPrimaryKeyColumns     = []string{"id"}
	quoteOperationGeneratedColumns      = []string{}
)

type (
	// QuoteOperationSlice is an alias for a slice of pointers to QuoteOperation.
	// This should almost always be used instead of []QuoteOperation.
	QuoteOperationSlice []*QuoteOperation
	// QuoteOperationHook is the signature for custom QuoteOperation hook methods
	QuoteOperationHook func(context.Context, boil.ContextExecutor, *QuoteOperation) error

	quoteOperationQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	quoteOperationType                 = reflect.TypeOf(&QuoteOperation{})
	quoteOperationMapping              = queries.MakeStructMapping(quoteOperationType)
	quoteOperationPrimaryKeyMapping, _ = queries.BindMapping(quoteOperationType, quoteOperationMapping, quoteOperationPrimaryKeyColumns)
	quoteOperationInsertCacheMut       sync.RWMutex
	quoteOperationInsertCache          = make(map[string]insertCache)
	quoteOperationUpdateCacheMut       sync.RWMutex
	quoteOperationUpdateCache          = make(map[string]updateCache)
	quoteOperationUpsertCacheMut       sync.RWMutex
	quoteOperationUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var quoteOperationAfterSelectMu sync.Mutex
var quoteOperationAfterSelectHooks []QuoteOperationHook

var quoteOperationBeforeInsertMu sync.Mutex
var quoteOperationBeforeInsertHooks []QuoteOperationHook
var quoteOperationAfterInsertMu sync.Mutex
var quoteOperationAfterInsertHooks []QuoteOperationHook

var quoteOperationBeforeUpdateMu sync.Mutex
var quoteOperationBeforeUpdateHooks []QuoteOperationHook
var quoteOperationAfterUpdateMu sync.Mutex
var quoteOperationAfterUpdateHooks []QuoteOperationHook

var quoteOperationBeforeDeleteMu sync.Mutex
var quoteOperationBeforeDeleteHooks []QuoteOperationHook
var quoteOperationAfterDeleteMu sync.Mutex
var quoteOperationAfterDeleteHooks []QuoteOperationHook

var quoteOperationBeforeUpsertMu sync.Mutex
var quoteOperationBeforeUpsertHooks []QuoteOperationHook
var quoteOperationAfterUpsertMu sync.Mutex
var quoteOperationAfterUpsertHooks []QuoteOperationHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *QuoteOperation) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteOperationAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *QuoteOperation) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteOperationBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *QuoteOperation) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteOperationAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *QuoteOperation) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteOperationBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *QuoteOperation) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteOperationAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *QuoteOperation) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteOperationBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *QuoteOperation) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteOperationAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *QuoteOperation) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteOperationBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *QuoteOperation) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range quoteOperationAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddQuoteOperationHook registers your hook function for all future operations.
func AddQuoteOperationHook(hookPoint boil.HookPoint, quoteOperationHook QuoteOperationHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		quoteOperationAfterSelectMu.Lock()
		quoteOperationAfterSelectHooks = append(quoteOperationAfterSelectHooks, quoteOperationHook)
		quoteOperationAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		quoteOperationBeforeInsertMu.Lock()
		quoteOperationBeforeInsertHooks = append(quoteOperationBeforeInsertHooks, quoteOperationHook)
		quoteOperationBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		quoteOperationAfterInsertMu.Lock()
		quoteOperationAfterInsertHooks = append(quoteOperationAfterInsertHooks, quoteOperationHook)
		quoteOperationAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		quoteOperationBeforeUpdateMu.Lock()
		quoteOperationBeforeUpdateHooks = append(quoteOperationBeforeUpdateHooks, quoteOperationHook)
		quoteOperationBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		quoteOperationAfterUpdateMu.Lock()
		quoteOperationAfterUpdateHooks = append(quoteOperationAfterUpdateHooks, quoteOperationHook)
		quoteOperationAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		quoteOperationBeforeDeleteMu.Lock()
		quoteOperationBeforeDeleteHooks = append(quoteOperationBeforeDeleteHooks, quoteOperationHook)
		quoteOperationBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		quoteOperationAfterDeleteMu.Lock()
		quoteOperationAfterDeleteHooks = append(quoteOperationAfterDeleteHooks, quoteOperationHook)
		quoteOperationAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		quoteOperationBeforeUpsertMu.Lock()
		quoteOperationBeforeUpsertHooks = append(quoteOperationBeforeUpsertHooks, quoteOperationHook)
		quoteOperationBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		quoteOperationAfterUpsertMu.Lock()
		quoteOperationAfterUpsertHooks = append(quoteOperationAfterUpsertHooks, quoteOperationHook)
		quoteOperationAfterUpsertMu.Unlock()
	}
}

// One returns a single quoteOperation record from the query.
func (q quoteOperationQuery) One(ctx context.Context, exec boil.ContextExecutor) (*QuoteOperation, error) {
	o := &QuoteOperation{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for quote_operation")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all QuoteOperation records from the query.
func (q quoteOperationQuery) All(ctx context.Context, exec boil.ContextExecutor) (QuoteOperationSlice, error) {
	var o []*QuoteOperation

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to QuoteOperation slice")
	}

	if len(quoteOperationAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all QuoteOperation records in the query.
func (q quoteOperationQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count quote_operation rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q quoteOperationQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if quote_operation exists")
	}

	return count > 0, nil
}

// FromAirport pointed to by the foreign key.
func (o *QuoteOperation) FromAirport(mods ...qm.QueryMod) airportQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.FromAirportID),
	}

	queryMods = append(queryMods, mods...)

	return Airports(queryMods...)
}

// ToAirport pointed to by the foreign key.
func (o *QuoteOperation) ToAirport(mods ...qm.QueryMod) airportQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ToAirportID),
	}

	queryMods = append(queryMods, mods...)

	return Airports(queryMods...)
}

// QuoteHeader pointed to by the foreign key.
func (o *QuoteOperation) QuoteHeader(mods ...qm.QueryMod) quoteHeaderQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.QuoteHeaderID),
	}

	queryMods = append(queryMods, mods...)

	return QuoteHeaders(queryMods...)
}

// Aircraft pointed to by the foreign key.
func (o *QuoteOperation) Aircraft(mods ...qm.QueryMod) aircraftQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.AircraftID),
	}

	queryMods = append(queryMods, mods...)

	return Aircrafts(queryMods...)
}

// CurrencyCodeCurrency pointed to by the foreign key.
func (o *QuoteOperation) CurrencyCodeCurrency(mods ...qm.QueryMod) currencyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"code\" = ?", o.CurrencyCode),
	}

	queryMods = append(queryMods, mods...)

	return Currencies(queryMods...)
}

// Team pointed to by the foreign key.
func (o *QuoteOperation) Team(mods ...qm.QueryMod) teamQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.TeamID),
	}

	queryMods = append(queryMods, mods...)

	return Teams(queryMods...)
}

// User pointed to by the foreign key.
func (o *QuoteOperation) User(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.UserID),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// QuoteResponse pointed to by the foreign key.
func (o *QuoteOperation) QuoteResponse(mods ...qm.QueryMod) quoteResponseQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.QuoteResponseID),
	}

	queryMods = append(queryMods, mods...)

	return QuoteResponses(queryMods...)
}

// Leg pointed to by the foreign key.
func (o *QuoteOperation) Leg(mods ...qm.QueryMod) emptyLegQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.LegID),
	}

	queryMods = append(queryMods, mods...)

	return EmptyLegs(queryMods...)
}

// LoadFromAirport allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteOperationL) LoadFromAirport(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuoteOperation interface{}, mods queries.Applicator) error {
	var slice []*QuoteOperation
	var object *QuoteOperation

	if singular {
		var ok bool
		object, ok = maybeQuoteOperation.(*QuoteOperation)
		if !ok {
			object = new(QuoteOperation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuoteOperation))
			}
		}
	} else {
		s, ok := maybeQuoteOperation.(*[]*QuoteOperation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuoteOperation))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteOperationR{}
		}
		args[object.FromAirportID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteOperationR{}
			}

			args[obj.FromAirportID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`airport`),
		qm.WhereIn(`airport.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Airport")
	}

	var resultSlice []*Airport
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Airport")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for airport")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for airport")
	}

	if len(airportAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.FromAirport = foreign
		if foreign.R == nil {
			foreign.R = &airportR{}
		}
		foreign.R.FromAirportQuoteOperations = append(foreign.R.FromAirportQuoteOperations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FromAirportID == foreign.ID {
				local.R.FromAirport = foreign
				if foreign.R == nil {
					foreign.R = &airportR{}
				}
				foreign.R.FromAirportQuoteOperations = append(foreign.R.FromAirportQuoteOperations, local)
				break
			}
		}
	}

	return nil
}

// LoadToAirport allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteOperationL) LoadToAirport(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuoteOperation interface{}, mods queries.Applicator) error {
	var slice []*QuoteOperation
	var object *QuoteOperation

	if singular {
		var ok bool
		object, ok = maybeQuoteOperation.(*QuoteOperation)
		if !ok {
			object = new(QuoteOperation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuoteOperation))
			}
		}
	} else {
		s, ok := maybeQuoteOperation.(*[]*QuoteOperation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuoteOperation))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteOperationR{}
		}
		args[object.ToAirportID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteOperationR{}
			}

			args[obj.ToAirportID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`airport`),
		qm.WhereIn(`airport.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Airport")
	}

	var resultSlice []*Airport
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Airport")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for airport")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for airport")
	}

	if len(airportAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ToAirport = foreign
		if foreign.R == nil {
			foreign.R = &airportR{}
		}
		foreign.R.ToAirportQuoteOperations = append(foreign.R.ToAirportQuoteOperations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ToAirportID == foreign.ID {
				local.R.ToAirport = foreign
				if foreign.R == nil {
					foreign.R = &airportR{}
				}
				foreign.R.ToAirportQuoteOperations = append(foreign.R.ToAirportQuoteOperations, local)
				break
			}
		}
	}

	return nil
}

// LoadQuoteHeader allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteOperationL) LoadQuoteHeader(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuoteOperation interface{}, mods queries.Applicator) error {
	var slice []*QuoteOperation
	var object *QuoteOperation

	if singular {
		var ok bool
		object, ok = maybeQuoteOperation.(*QuoteOperation)
		if !ok {
			object = new(QuoteOperation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuoteOperation))
			}
		}
	} else {
		s, ok := maybeQuoteOperation.(*[]*QuoteOperation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuoteOperation))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteOperationR{}
		}
		args[object.QuoteHeaderID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteOperationR{}
			}

			args[obj.QuoteHeaderID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`quote_header`),
		qm.WhereIn(`quote_header.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load QuoteHeader")
	}

	var resultSlice []*QuoteHeader
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice QuoteHeader")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for quote_header")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quote_header")
	}

	if len(quoteHeaderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.QuoteHeader = foreign
		if foreign.R == nil {
			foreign.R = &quoteHeaderR{}
		}
		foreign.R.QuoteOperations = append(foreign.R.QuoteOperations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.QuoteHeaderID == foreign.ID {
				local.R.QuoteHeader = foreign
				if foreign.R == nil {
					foreign.R = &quoteHeaderR{}
				}
				foreign.R.QuoteOperations = append(foreign.R.QuoteOperations, local)
				break
			}
		}
	}

	return nil
}

// LoadAircraft allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteOperationL) LoadAircraft(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuoteOperation interface{}, mods queries.Applicator) error {
	var slice []*QuoteOperation
	var object *QuoteOperation

	if singular {
		var ok bool
		object, ok = maybeQuoteOperation.(*QuoteOperation)
		if !ok {
			object = new(QuoteOperation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuoteOperation))
			}
		}
	} else {
		s, ok := maybeQuoteOperation.(*[]*QuoteOperation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuoteOperation))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteOperationR{}
		}
		if !queries.IsNil(object.AircraftID) {
			args[object.AircraftID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteOperationR{}
			}

			if !queries.IsNil(obj.AircraftID) {
				args[obj.AircraftID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`aircraft`),
		qm.WhereIn(`aircraft.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Aircraft")
	}

	var resultSlice []*Aircraft
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Aircraft")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for aircraft")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for aircraft")
	}

	if len(aircraftAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Aircraft = foreign
		if foreign.R == nil {
			foreign.R = &aircraftR{}
		}
		foreign.R.QuoteOperations = append(foreign.R.QuoteOperations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AircraftID, foreign.ID) {
				local.R.Aircraft = foreign
				if foreign.R == nil {
					foreign.R = &aircraftR{}
				}
				foreign.R.QuoteOperations = append(foreign.R.QuoteOperations, local)
				break
			}
		}
	}

	return nil
}

// LoadCurrencyCodeCurrency allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteOperationL) LoadCurrencyCodeCurrency(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuoteOperation interface{}, mods queries.Applicator) error {
	var slice []*QuoteOperation
	var object *QuoteOperation

	if singular {
		var ok bool
		object, ok = maybeQuoteOperation.(*QuoteOperation)
		if !ok {
			object = new(QuoteOperation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuoteOperation))
			}
		}
	} else {
		s, ok := maybeQuoteOperation.(*[]*QuoteOperation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuoteOperation))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteOperationR{}
		}
		if !queries.IsNil(object.CurrencyCode) {
			args[object.CurrencyCode] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteOperationR{}
			}

			if !queries.IsNil(obj.CurrencyCode) {
				args[obj.CurrencyCode] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`currency`),
		qm.WhereIn(`currency.code in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Currency")
	}

	var resultSlice []*Currency
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Currency")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for currency")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for currency")
	}

	if len(currencyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CurrencyCodeCurrency = foreign
		if foreign.R == nil {
			foreign.R = &currencyR{}
		}
		foreign.R.CurrencyCodeQuoteOperations = append(foreign.R.CurrencyCodeQuoteOperations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CurrencyCode, foreign.Code) {
				local.R.CurrencyCodeCurrency = foreign
				if foreign.R == nil {
					foreign.R = &currencyR{}
				}
				foreign.R.CurrencyCodeQuoteOperations = append(foreign.R.CurrencyCodeQuoteOperations, local)
				break
			}
		}
	}

	return nil
}

// LoadTeam allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteOperationL) LoadTeam(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuoteOperation interface{}, mods queries.Applicator) error {
	var slice []*QuoteOperation
	var object *QuoteOperation

	if singular {
		var ok bool
		object, ok = maybeQuoteOperation.(*QuoteOperation)
		if !ok {
			object = new(QuoteOperation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuoteOperation))
			}
		}
	} else {
		s, ok := maybeQuoteOperation.(*[]*QuoteOperation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuoteOperation))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteOperationR{}
		}
		args[object.TeamID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteOperationR{}
			}

			args[obj.TeamID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`team`),
		qm.WhereIn(`team.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Team")
	}

	var resultSlice []*Team
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Team")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for team")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for team")
	}

	if len(teamAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Team = foreign
		if foreign.R == nil {
			foreign.R = &teamR{}
		}
		foreign.R.QuoteOperations = append(foreign.R.QuoteOperations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.TeamID == foreign.ID {
				local.R.Team = foreign
				if foreign.R == nil {
					foreign.R = &teamR{}
				}
				foreign.R.QuoteOperations = append(foreign.R.QuoteOperations, local)
				break
			}
		}
	}

	return nil
}

// LoadUser allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteOperationL) LoadUser(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuoteOperation interface{}, mods queries.Applicator) error {
	var slice []*QuoteOperation
	var object *QuoteOperation

	if singular {
		var ok bool
		object, ok = maybeQuoteOperation.(*QuoteOperation)
		if !ok {
			object = new(QuoteOperation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuoteOperation))
			}
		}
	} else {
		s, ok := maybeQuoteOperation.(*[]*QuoteOperation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuoteOperation))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteOperationR{}
		}
		args[object.UserID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteOperationR{}
			}

			args[obj.UserID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.User = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.QuoteOperations = append(foreign.R.QuoteOperations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.UserID == foreign.ID {
				local.R.User = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.QuoteOperations = append(foreign.R.QuoteOperations, local)
				break
			}
		}
	}

	return nil
}

// LoadQuoteResponse allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteOperationL) LoadQuoteResponse(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuoteOperation interface{}, mods queries.Applicator) error {
	var slice []*QuoteOperation
	var object *QuoteOperation

	if singular {
		var ok bool
		object, ok = maybeQuoteOperation.(*QuoteOperation)
		if !ok {
			object = new(QuoteOperation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuoteOperation))
			}
		}
	} else {
		s, ok := maybeQuoteOperation.(*[]*QuoteOperation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuoteOperation))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteOperationR{}
		}
		if !queries.IsNil(object.QuoteResponseID) {
			args[object.QuoteResponseID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteOperationR{}
			}

			if !queries.IsNil(obj.QuoteResponseID) {
				args[obj.QuoteResponseID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`quote_response`),
		qm.WhereIn(`quote_response.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load QuoteResponse")
	}

	var resultSlice []*QuoteResponse
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice QuoteResponse")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for quote_response")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quote_response")
	}

	if len(quoteResponseAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.QuoteResponse = foreign
		if foreign.R == nil {
			foreign.R = &quoteResponseR{}
		}
		foreign.R.QuoteOperation = object
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.QuoteResponseID, foreign.ID) {
				local.R.QuoteResponse = foreign
				if foreign.R == nil {
					foreign.R = &quoteResponseR{}
				}
				foreign.R.QuoteOperation = local
				break
			}
		}
	}

	return nil
}

// LoadLeg allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (quoteOperationL) LoadLeg(ctx context.Context, e boil.ContextExecutor, singular bool, maybeQuoteOperation interface{}, mods queries.Applicator) error {
	var slice []*QuoteOperation
	var object *QuoteOperation

	if singular {
		var ok bool
		object, ok = maybeQuoteOperation.(*QuoteOperation)
		if !ok {
			object = new(QuoteOperation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeQuoteOperation))
			}
		}
	} else {
		s, ok := maybeQuoteOperation.(*[]*QuoteOperation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeQuoteOperation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeQuoteOperation))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &quoteOperationR{}
		}
		if !queries.IsNil(object.LegID) {
			args[object.LegID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &quoteOperationR{}
			}

			if !queries.IsNil(obj.LegID) {
				args[obj.LegID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`empty_leg`),
		qm.WhereIn(`empty_leg.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load EmptyLeg")
	}

	var resultSlice []*EmptyLeg
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice EmptyLeg")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for empty_leg")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for empty_leg")
	}

	if len(emptyLegAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Leg = foreign
		if foreign.R == nil {
			foreign.R = &emptyLegR{}
		}
		foreign.R.LegQuoteOperations = append(foreign.R.LegQuoteOperations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.LegID, foreign.ID) {
				local.R.Leg = foreign
				if foreign.R == nil {
					foreign.R = &emptyLegR{}
				}
				foreign.R.LegQuoteOperations = append(foreign.R.LegQuoteOperations, local)
				break
			}
		}
	}

	return nil
}

// SetFromAirport of the quoteOperation to the related item.
// Sets o.R.FromAirport to related.
// Adds o to related.R.FromAirportQuoteOperations.
func (o *QuoteOperation) SetFromAirport(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Airport) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote_operation\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"from_airport_id"}),
		strmangle.WhereClause("\"", "\"", 2, quoteOperationPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.FromAirportID = related.ID
	if o.R == nil {
		o.R = &quoteOperationR{
			FromAirport: related,
		}
	} else {
		o.R.FromAirport = related
	}

	if related.R == nil {
		related.R = &airportR{
			FromAirportQuoteOperations: QuoteOperationSlice{o},
		}
	} else {
		related.R.FromAirportQuoteOperations = append(related.R.FromAirportQuoteOperations, o)
	}

	return nil
}

// SetToAirport of the quoteOperation to the related item.
// Sets o.R.ToAirport to related.
// Adds o to related.R.ToAirportQuoteOperations.
func (o *QuoteOperation) SetToAirport(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Airport) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote_operation\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"to_airport_id"}),
		strmangle.WhereClause("\"", "\"", 2, quoteOperationPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ToAirportID = related.ID
	if o.R == nil {
		o.R = &quoteOperationR{
			ToAirport: related,
		}
	} else {
		o.R.ToAirport = related
	}

	if related.R == nil {
		related.R = &airportR{
			ToAirportQuoteOperations: QuoteOperationSlice{o},
		}
	} else {
		related.R.ToAirportQuoteOperations = append(related.R.ToAirportQuoteOperations, o)
	}

	return nil
}

// SetQuoteHeader of the quoteOperation to the related item.
// Sets o.R.QuoteHeader to related.
// Adds o to related.R.QuoteOperations.
func (o *QuoteOperation) SetQuoteHeader(ctx context.Context, exec boil.ContextExecutor, insert bool, related *QuoteHeader) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote_operation\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"quote_header_id"}),
		strmangle.WhereClause("\"", "\"", 2, quoteOperationPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.QuoteHeaderID = related.ID
	if o.R == nil {
		o.R = &quoteOperationR{
			QuoteHeader: related,
		}
	} else {
		o.R.QuoteHeader = related
	}

	if related.R == nil {
		related.R = &quoteHeaderR{
			QuoteOperations: QuoteOperationSlice{o},
		}
	} else {
		related.R.QuoteOperations = append(related.R.QuoteOperations, o)
	}

	return nil
}

// SetAircraft of the quoteOperation to the related item.
// Sets o.R.Aircraft to related.
// Adds o to related.R.QuoteOperations.
func (o *QuoteOperation) SetAircraft(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Aircraft) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote_operation\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"aircraft_id"}),
		strmangle.WhereClause("\"", "\"", 2, quoteOperationPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AircraftID, related.ID)
	if o.R == nil {
		o.R = &quoteOperationR{
			Aircraft: related,
		}
	} else {
		o.R.Aircraft = related
	}

	if related.R == nil {
		related.R = &aircraftR{
			QuoteOperations: QuoteOperationSlice{o},
		}
	} else {
		related.R.QuoteOperations = append(related.R.QuoteOperations, o)
	}

	return nil
}

// RemoveAircraft relationship.
// Sets o.R.Aircraft to nil.
// Removes o from all passed in related items' relationships struct.
func (o *QuoteOperation) RemoveAircraft(ctx context.Context, exec boil.ContextExecutor, related *Aircraft) error {
	var err error

	queries.SetScanner(&o.AircraftID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("aircraft_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Aircraft = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.QuoteOperations {
		if queries.Equal(o.AircraftID, ri.AircraftID) {
			continue
		}

		ln := len(related.R.QuoteOperations)
		if ln > 1 && i < ln-1 {
			related.R.QuoteOperations[i] = related.R.QuoteOperations[ln-1]
		}
		related.R.QuoteOperations = related.R.QuoteOperations[:ln-1]
		break
	}
	return nil
}

// SetCurrencyCodeCurrency of the quoteOperation to the related item.
// Sets o.R.CurrencyCodeCurrency to related.
// Adds o to related.R.CurrencyCodeQuoteOperations.
func (o *QuoteOperation) SetCurrencyCodeCurrency(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Currency) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote_operation\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"currency_code"}),
		strmangle.WhereClause("\"", "\"", 2, quoteOperationPrimaryKeyColumns),
	)
	values := []interface{}{related.Code, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CurrencyCode, related.Code)
	if o.R == nil {
		o.R = &quoteOperationR{
			CurrencyCodeCurrency: related,
		}
	} else {
		o.R.CurrencyCodeCurrency = related
	}

	if related.R == nil {
		related.R = &currencyR{
			CurrencyCodeQuoteOperations: QuoteOperationSlice{o},
		}
	} else {
		related.R.CurrencyCodeQuoteOperations = append(related.R.CurrencyCodeQuoteOperations, o)
	}

	return nil
}

// RemoveCurrencyCodeCurrency relationship.
// Sets o.R.CurrencyCodeCurrency to nil.
// Removes o from all passed in related items' relationships struct.
func (o *QuoteOperation) RemoveCurrencyCodeCurrency(ctx context.Context, exec boil.ContextExecutor, related *Currency) error {
	var err error

	queries.SetScanner(&o.CurrencyCode, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("currency_code")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.CurrencyCodeCurrency = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CurrencyCodeQuoteOperations {
		if queries.Equal(o.CurrencyCode, ri.CurrencyCode) {
			continue
		}

		ln := len(related.R.CurrencyCodeQuoteOperations)
		if ln > 1 && i < ln-1 {
			related.R.CurrencyCodeQuoteOperations[i] = related.R.CurrencyCodeQuoteOperations[ln-1]
		}
		related.R.CurrencyCodeQuoteOperations = related.R.CurrencyCodeQuoteOperations[:ln-1]
		break
	}
	return nil
}

// SetTeam of the quoteOperation to the related item.
// Sets o.R.Team to related.
// Adds o to related.R.QuoteOperations.
func (o *QuoteOperation) SetTeam(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Team) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote_operation\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"team_id"}),
		strmangle.WhereClause("\"", "\"", 2, quoteOperationPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.TeamID = related.ID
	if o.R == nil {
		o.R = &quoteOperationR{
			Team: related,
		}
	} else {
		o.R.Team = related
	}

	if related.R == nil {
		related.R = &teamR{
			QuoteOperations: QuoteOperationSlice{o},
		}
	} else {
		related.R.QuoteOperations = append(related.R.QuoteOperations, o)
	}

	return nil
}

// SetUser of the quoteOperation to the related item.
// Sets o.R.User to related.
// Adds o to related.R.QuoteOperations.
func (o *QuoteOperation) SetUser(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote_operation\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
		strmangle.WhereClause("\"", "\"", 2, quoteOperationPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.UserID = related.ID
	if o.R == nil {
		o.R = &quoteOperationR{
			User: related,
		}
	} else {
		o.R.User = related
	}

	if related.R == nil {
		related.R = &userR{
			QuoteOperations: QuoteOperationSlice{o},
		}
	} else {
		related.R.QuoteOperations = append(related.R.QuoteOperations, o)
	}

	return nil
}

// SetQuoteResponse of the quoteOperation to the related item.
// Sets o.R.QuoteResponse to related.
// Adds o to related.R.QuoteOperation.
func (o *QuoteOperation) SetQuoteResponse(ctx context.Context, exec boil.ContextExecutor, insert bool, related *QuoteResponse) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote_operation\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"quote_response_id"}),
		strmangle.WhereClause("\"", "\"", 2, quoteOperationPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.QuoteResponseID, related.ID)
	if o.R == nil {
		o.R = &quoteOperationR{
			QuoteResponse: related,
		}
	} else {
		o.R.QuoteResponse = related
	}

	if related.R == nil {
		related.R = &quoteResponseR{
			QuoteOperation: o,
		}
	} else {
		related.R.QuoteOperation = o
	}

	return nil
}

// RemoveQuoteResponse relationship.
// Sets o.R.QuoteResponse to nil.
// Removes o from all passed in related items' relationships struct.
func (o *QuoteOperation) RemoveQuoteResponse(ctx context.Context, exec boil.ContextExecutor, related *QuoteResponse) error {
	var err error

	queries.SetScanner(&o.QuoteResponseID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("quote_response_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.QuoteResponse = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	related.R.QuoteOperation = nil
	return nil
}

// SetLeg of the quoteOperation to the related item.
// Sets o.R.Leg to related.
// Adds o to related.R.LegQuoteOperations.
func (o *QuoteOperation) SetLeg(ctx context.Context, exec boil.ContextExecutor, insert bool, related *EmptyLeg) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"quote_operation\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"leg_id"}),
		strmangle.WhereClause("\"", "\"", 2, quoteOperationPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.LegID, related.ID)
	if o.R == nil {
		o.R = &quoteOperationR{
			Leg: related,
		}
	} else {
		o.R.Leg = related
	}

	if related.R == nil {
		related.R = &emptyLegR{
			LegQuoteOperations: QuoteOperationSlice{o},
		}
	} else {
		related.R.LegQuoteOperations = append(related.R.LegQuoteOperations, o)
	}

	return nil
}

// RemoveLeg relationship.
// Sets o.R.Leg to nil.
// Removes o from all passed in related items' relationships struct.
func (o *QuoteOperation) RemoveLeg(ctx context.Context, exec boil.ContextExecutor, related *EmptyLeg) error {
	var err error

	queries.SetScanner(&o.LegID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("leg_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Leg = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.LegQuoteOperations {
		if queries.Equal(o.LegID, ri.LegID) {
			continue
		}

		ln := len(related.R.LegQuoteOperations)
		if ln > 1 && i < ln-1 {
			related.R.LegQuoteOperations[i] = related.R.LegQuoteOperations[ln-1]
		}
		related.R.LegQuoteOperations = related.R.LegQuoteOperations[:ln-1]
		break
	}
	return nil
}

// QuoteOperations retrieves all the records using an executor.
func QuoteOperations(mods ...qm.QueryMod) quoteOperationQuery {
	mods = append(mods, qm.From("\"quote_operation\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"quote_operation\".*"})
	}

	return quoteOperationQuery{q}
}

// FindQuoteOperation retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindQuoteOperation(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*QuoteOperation, error) {
	quoteOperationObj := &QuoteOperation{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"quote_operation\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, quoteOperationObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from quote_operation")
	}

	if err = quoteOperationObj.doAfterSelectHooks(ctx, exec); err != nil {
		return quoteOperationObj, err
	}

	return quoteOperationObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *QuoteOperation) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no quote_operation provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(quoteOperationColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	quoteOperationInsertCacheMut.RLock()
	cache, cached := quoteOperationInsertCache[key]
	quoteOperationInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			quoteOperationAllColumns,
			quoteOperationColumnsWithDefault,
			quoteOperationColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(quoteOperationType, quoteOperationMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(quoteOperationType, quoteOperationMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"quote_operation\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"quote_operation\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into quote_operation")
	}

	if !cached {
		quoteOperationInsertCacheMut.Lock()
		quoteOperationInsertCache[key] = cache
		quoteOperationInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the QuoteOperation.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *QuoteOperation) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	quoteOperationUpdateCacheMut.RLock()
	cache, cached := quoteOperationUpdateCache[key]
	quoteOperationUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			quoteOperationAllColumns,
			quoteOperationPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update quote_operation, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"quote_operation\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, quoteOperationPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(quoteOperationType, quoteOperationMapping, append(wl, quoteOperationPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update quote_operation row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for quote_operation")
	}

	if !cached {
		quoteOperationUpdateCacheMut.Lock()
		quoteOperationUpdateCache[key] = cache
		quoteOperationUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q quoteOperationQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for quote_operation")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for quote_operation")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o QuoteOperationSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), quoteOperationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"quote_operation\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, quoteOperationPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in quoteOperation slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all quoteOperation")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *QuoteOperation) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("dbmodels: no quote_operation provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(quoteOperationColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	quoteOperationUpsertCacheMut.RLock()
	cache, cached := quoteOperationUpsertCache[key]
	quoteOperationUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			quoteOperationAllColumns,
			quoteOperationColumnsWithDefault,
			quoteOperationColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			quoteOperationAllColumns,
			quoteOperationPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert quote_operation, could not build update column list")
		}

		ret := strmangle.SetComplement(quoteOperationAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(quoteOperationPrimaryKeyColumns) == 0 {
				return errors.New("dbmodels: unable to upsert quote_operation, could not build conflict column list")
			}

			conflict = make([]string, len(quoteOperationPrimaryKeyColumns))
			copy(conflict, quoteOperationPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"quote_operation\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(quoteOperationType, quoteOperationMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(quoteOperationType, quoteOperationMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert quote_operation")
	}

	if !cached {
		quoteOperationUpsertCacheMut.Lock()
		quoteOperationUpsertCache[key] = cache
		quoteOperationUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single QuoteOperation record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *QuoteOperation) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no QuoteOperation provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), quoteOperationPrimaryKeyMapping)
	sql := "DELETE FROM \"quote_operation\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from quote_operation")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for quote_operation")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q quoteOperationQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no quoteOperationQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from quote_operation")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for quote_operation")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o QuoteOperationSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(quoteOperationBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), quoteOperationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"quote_operation\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, quoteOperationPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from quoteOperation slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for quote_operation")
	}

	if len(quoteOperationAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *QuoteOperation) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindQuoteOperation(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *QuoteOperationSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := QuoteOperationSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), quoteOperationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"quote_operation\".* FROM \"quote_operation\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, quoteOperationPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in QuoteOperationSlice")
	}

	*o = slice

	return nil
}

// QuoteOperationExists checks if the QuoteOperation row exists.
func QuoteOperationExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"quote_operation\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if quote_operation exists")
	}

	return exists, nil
}

// Exists checks if the QuoteOperation row exists.
func (o *QuoteOperation) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return QuoteOperationExists(ctx, exec, o.ID)
}
